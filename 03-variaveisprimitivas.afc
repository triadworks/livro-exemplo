[chapter Variáveis primitivas e Controle de fluxo]

[quote "Péssima idéia, a de que não se pode mudar" -- Montaigne]

Aprenderemos a trabalhar com os seguintes recursos da linguagem Java:
[list]
* declaração, atribuição de valores, casting e comparação de variáveis;
* controle de fluxo através de %%if%% e %%else%%;
* instruções de laço %%for%% e %%while%%, controle de fluxo com break e continue.
[/list]

[note]
* evite usar aqui termos como classes, objetos e métodos.

* aprender java não é fácil, no começo utilizamos muita coisa (como public, static, class) 
que ainda não sabemos o que faz, mas no decorrer do curso vamos aprender *todas* as palavras 
chaves que estamos utilizando

* atentar aos alunos para a maisuculas e minisculas.

* forca-los a usar ConvencoesDeNomenclatura, e a identar corretamente o codigo.
 
* boolean não é 0,1 não é 'V', 'F', nem similares.

* Mostrar os tipos de primitivos mais comuns (int, double, char e boolean) e a sintaxe de declaração. 
Lembrar de escrever sempre o código completo para que fique claro que estas declarações, neste momento, 
ficarão dentro no main.

* Fazer algumas charadas de conversão, como por exemplo:
   double valor = 3;
   int valorInteiro = valor; (isso compila??)

* Importante dizer que o operador de igual (=), copia e cola o valor da variável. Isso será 
  importante na hora em que trabalharmos com referências.

* Testando os códigos desenvolvidos acima (Comentar aqui a diferença entre compilação e execução em Java).

* Caso surja alguma pergunta relacionado com String, basta comentar que estudaremos em um capítulo mais a frente.

* Sobre casting, eu sei que eu posso perder informação, mas estou ciente disso, e se 
der algum problema a culpa é *SUA*.
[/note]

[section Declarando e usando variáveis]
[index variáveis]
**Dentro de um bloco**, podemos declarar variáveis e usá-las. Em Java, toda variável tem um tipo que não
pode ser mudado, uma vez que declarado:

[code]
tipoDaVariavel nomeDaVariavel;
[/code]

[index int]
Por exemplo, é possível ter uma %%idade%% que guarda um número inteiro:

[code java]
int idade;
[/code]

Com isso, você declara a variável %%idade%%, que passa a existir a partir daquela linha. Ela é do 
tipo %%int%%, que guarda um número inteiro. A partir daí, você pode usá-la, primeiramente
atribuindo valores.

A linha a seguir é a tradução de: **"%%idade%% deve valer quinze"**.

[code java]
idade = 15;
[/code]

[box Comentários em Java]
Para fazer um comentário em java, você pode usar o %%//%% para comentar até o final da linha, ou então 
usar o %%/* */%% para comentar o que estiver entre eles.
 
	[code java]
	 /* comentário daqui,
	ate aqui */
	
	// uma linha de comentário sobre a idade
	int idade;
	[/code]
[/box]

Além de atribuir, você pode utilizar esse valor. O código a seguir declara novamente a variável 
%%idade%% com valor 15 e imprime seu valor na saída padrão através da chamada a %%System.out.println%%.

[code java]
// declara a idade
int idade;
idade = 15;
	
// imprime a idade
System.out.println(idade);
[/code]

Por fim, podemos utilizar o valor de uma variável para algum outro propósito, como alterar ou 
definir uma segunda variável. O código a seguir cria uma variável chamada %%idadeNoAnoQueVem%% com 
valor de **idade mais um**.

[code java]
// calcula a idade no ano seguinte
int idadeNoAnoQueVem;
idadeNoAnoQueVem = idade + 1;
[/code]

No mesmo momento que você declara uma variável, também é possível inicializá-la por praticidade:

[code java]
int idade = 15;
[/code]

[index OPERADORES ARITMÉTICOS]

Você pode usar os operadores +, -, / e * para operar com números, sendo eles responsáveis 
pela adição, subtração, divisão e multiplicação, respectivamente. Além desses operadores 
básicos, há o operador % (módulo) que nada mais é que o **resto de uma divisão inteira**. 
Veja alguns exemplos:

[code java]
int quatro = 2 + 2;
int tres = 5 - 2;
	
int oito = 4 * 2;
int dezesseis = 64 / 4;
	
int um = 5 % 2; // 5 dividido por 2 dá 2 e tem resto 1; 
     		   // o operador % pega o resto da divisão inteira
[/code]

[box Como rodar esses códigos?]
Você deve colocar esses trechos de código dentro do bloco main que vimos no capítulo anterior. 
Isto é, isso deve ficar no miolo do programa. Use bastante %%System.out.println%%, dessa forma você 
pode ver algum resultado, caso contrário, ao executar a aplicação, nada aparecerá.

Por exemplo, para imprimir a %%idade%% e a %%idadeNoAnoQueVem%% podemos escrever o seguinte programa 
de exemplo:

[code java]
class TestaIdade {

	public static void main(String[] args) {
		// imprime a idade
		int idade = 20;
		System.out.println(idade);

		// gera uma idade no ano seguinte
		int idadeNoAnoQueVem;
		idadeNoAnoQueVem = idade + 1;

		// imprime a idade
		System.out.println(idadeNoAnoQueVem);
	}
}
[/code]
[/box]

[index DOUBLE]
Representar números inteiros é fácil, mas como guardar valores reais, tais como frações de números 
inteiros e outros? Outro tipo de variável muito utilizado é o %%double%%, que armazena um número 
com ponto flutuante (e que também pode armazenar um número inteiro).

[code java]
double pi = 3.14;
double x = 5 * 10;
[/code]

[index boolean]
O tipo boolean armazena um valor verdadeiro ou falso, e só: nada de números,
palavras ou endereços, como em algumas outras linguagens.

[code java]
boolean verdade = true;
[/code]

%%true%% e %%false%% são palavras reservadas do Java. É comum que um %%boolean%%
seja determinado através de uma **expressão booleana**, isto é, um trecho
de código que retorna um booleano, como o exemplo:

[code java]
int idade = 30;
boolean menorDeIdade = idade < 18;
[/code]


[index CHAR]
O tipo char guarda um, e apenas um, caractere. Esse caractere deve estar entre aspas simples. Não se 
esqueça dessas duas características de uma variável do tipo char! Por exemplo, ela não pode guardar 
um código como %%''%% pois o vazio não é um caractere!

[code java]
char letra = 'a';
System.out.println(letra);
[/code]

Variáveis do tipo %%char%% são pouco usadas no dia a dia. Veremos mais a frente
o uso das %%String%%s, que usamos constantemente, porém estas não são definidas por
um tipo primitivo.

[section Tipos primitivos e valores]

[index ATRIBUIÇÃO]
Esses tipos de variáveis são tipos primitivos do Java: o valor que elas guardam são o real conteúdo 
da variável. Quando você utilizar o **operador de atribuição** %%=%% o valor será **copiado**.

[code java]
int i = 5; // i recebe uma cópia do valor 5
int j = i; // j recebe uma cópia do valor de i
i = i + 1; // i vira 6, j continua 5
[/code]

Aqui, %%i%% fica com o valor de 6. Mas e %%j%%? Na segunda linha, %%j%% está valendo 5. Quando 
%%i%% passa a valer 6, será que %%j%% também muda de valor? Não, pois o valor de um tipo primitivo
 sempre é copiado.

Apesar da linha 2 fazer %%j = i%%, a partir desse momento essas variáveis não tem relação nenhuma: 
o que acontece com uma, não reflete em nada com a outra.

[note]
Essa explicacao, que pode parecer desinteressante aos alunos ao primeiro instante, vai ser muito util ao
mostrar referencias, e que elas sao passadas por valor. A analogia ajuda bastante.
[/note]

[box Outros tipos primitivos]
Vimos aqui os tipos primitivos que mais aparecem. O Java tem outros, que são o %%byte%%, %%short%%,
 %%long%% e %%float%%.

Cada tipo possui características especiais que, para um programador avançado, podem fazer muita
diferença.
[/box]

[section Exercícios: Variáveis e tipos primitivos]

[exercise]
[question]
Na empresa onde trabalhamos, há tabelas com o quanto foi gasto em cada mês. Para fechar o balanço do 
primeiro trimestre, precisamos somar o gasto total. Sabendo que, em Janeiro, foram gastos 15000 
reais, em Fevereiro, 23000 reais e em Março, 17000 reais, faça um programa que calcule e imprima o 
gasto total no trimestre. Siga esses passos:

[list letter]
* Crie uma classe chamada %%BalancoTrimestral%% com um bloco main, como nos exemplos anteriores;
* Dentro do %%main%% (o miolo do programa), declare uma variável inteira chamada %%gastosJaneiro%% e 
inicialize-a com 15000;
* Crie também as variáveis %%gastosFevereiro%% e %%gastosMarco%%, inicializando-as com 23000 e 17000, 
respectivamente, utilize uma linha para cada declaração;
* Crie uma variável chamada %%gastosTrimestre%% e inicialize-a com a soma das outras 3 variáveis:

[code java]
int gastosTrimestre = gastosJaneiro + gastosFevereiro + gastosMarco;
[/code]

* Imprima a variável %%gastosTrimestre%%.
[/list]
[/question]

[question]
Adicione código (sem alterar as linhas que já existem) na classe anterior para imprimir 
a média mensal de gasto, criando uma variável %%mediaMensal%% junto com uma mensagem. 
Para isso, concatene a %%String%% com o valor, usando %%"Valor da média mensal = " + mediaMensal%%.
[/question]
[/exercise]

[section Discussão em aula: convenções de código e código legível]
[note]
	Falar das code conventions do Java. Nome de classe em maiuscula, variaveis e metodos
	em minuscula. Falar do camel-case. Falar que abre chaves fica na linha do bloco.
	Pode comparar com C# por exemplo onde metodo eh maiuscula e o abre chaves fica na linha
	de baixo.
	
	Falar que eh bom para manter padrao e todos se entenderem.
	
	Comentar o exercicio do BalancoTrimestral, porque escrever variaveis grandes como
	'gastosJaneiro' (muitos alunos abreviam no exercicio, fazendo 'janeiro' ou 'jan' ou 'gj').
	Falar que se suas variaveis sao 'janeiro', 'fevereiro' etc como saber se o programa calcula
	gastos ou ganhos no trimestre? Colocando comentarios?
	
	Falar que evita-se colocar comentarios ao maximo para fazer codigo legivel, que se auto
	explique. Martin Fowler diz isso no 'Refactoring', pg 87.
[/note]

Discuta com o instrutor e seus colegas sobre convenções de código Java. Por que existem?
Por que são importantes?

Discuta também as vantagens de se escrever código fácil de ler e se evitar comentários em
excesso.

(Dica: procure por ::code conventions:: no campo de busca do site http://java.sun.com.)

[section Casting e promoção]

[note]
Esse note vale tanto pro FJ11 qto pro FJ19.

Eu costumo falar que o tipo do dado é uma garagem e o dado que vc está querendo guardar
nesse tipo é um carro. (Faço isso com a ordem crescente do tamanho dos tipos primitivos na lousa)

Então você vai estacionar o carro numa garagem, o carro pode ser maior, menor ou caber 
direitinho na garagem. Se o carro é menor ou cabe direitinho na garagem, nao tem problema
nenhum, o compilador fica feliz pq ele sabe que o que vc vai fazer tem que funcionar.

O problema acontece quando vc quer guardar um carro muito grande em uma garagem pequena.
O compilador percebe que se vc quiser estacionar um caminhao (long), numa garagem q eh pra um
fusca (short) boa coisa nao vai acontecer, entao ele impede que isso aconteça (eu falo que o compilador 
fica de braços cruzados na frente da garagem impedindo vc de estacionar seu carro lá, como se fosse
um segurança). Pra conseguir colocar o caminhão na garagem, voce precisa avisar o segurança e falar q
vc tem consciencia do q está fazendo. "Hey, segurança, eu sei q eu estou com um caminhao e sei q 
se eu estacionar nessa garagem eu posso perder os espelhos e arranhar o meu caminhao... mas é isso 
q eu quero fazer, então, dá licença, por favor.". Como vc foi educado e compilador vai deixar.

Perder os espelhos é a deixa pra vc falar de qdo vc quer colocar um double num long.
[/note]

Alguns valores são incompatíveis se você tentar fazer uma atribuição direta. Enquanto um número real 
costuma ser representado em uma variável do tipo %%double%%, tentar atribuir ele a uma variável 
%%int%% não funciona porque é um código que diz: **"i deve valer d"**, mas não se sabe se %%d%%
realmente é um número inteiro ou não.

[code java]
double d = 3.1415;
int i = d; // não compila
[/code]

O mesmo ocorre no seguinte trecho:

[code java]
int i = 3.14;
[/code]

O mais interessante, é que nem mesmo o seguinte código compila:

[code java]
double d = 5; // ok, o double pode conter um número inteiro
int i = d; // não compila
[/code]

Apesar de 5 ser um bom valor para um %%int%%, o compilador não tem como saber que valor estará dentro
desse %%double%% no momento da execução. Esse valor pode ter sido digitado pelo usuário, e ninguém
vai garantir que essa conversão ocorra sem perda de valores.

Já no caso a seguir, é o contrário:

[code java]
int i = 5;
double d2 = i;
[/code]

O código acima compila sem problemas, já que um %%double%% pode guardar um número com ou sem ponto 
flutuante. Todos os inteiros representados por uma variável do tipo %%int%% podem ser guardados em 
uma variável double, então não existem problemas no código acima.  

[index CASTING]
Às vezes, precisamos que um número quebrado seja arredondado e armazenado num número inteiro. 
Para fazer isso sem que haja o erro de compilação, é preciso ordenar que o número quebrado seja 
**moldado (casted)** como um número inteiro. Esse processo recebe o nome de **casting**.

[code java]
double d3 = 3.14;
int i = (int) d3;
[/code]

O casting foi feito para moldar a variável %%d3%% como um %%int%%. O valor de %%i%% agora é 3.

O mesmo ocorre entre valores %%int%% e %%long%%.

[code java]
long x = 10000;
int i = x; // não compila, pois pode estar perdendo informação
[/code]

E, se quisermos realmente fazer isso, fazemos o casting:

[code java]
long x = 10000;
int i = (int) x;
[/code]

[box Casos não tão comuns de casting e atribuição]
Alguns **castings** aparecem também:

[code java]
float x = 0.0;
[/code]

O código acima não compila pois todos os literais com ponto flutuante são considerados 
%%double%% pelo Java. E %%float%% não pode receber um %%double%% sem perda de informação, para fazer 
isso funcionar podemos escrever o seguinte:

[code java]
float x = 0.0f;
[/code]

A letra f, que pode ser maiuscula ou minúscula, indica que aquele literal deve ser tratado como 
%%float%%. 

Outro caso, que é mais comum:

[code java]
double d = 5;
float f = 3;

float x = f + (float) d;
[/code]

Você precisa do casting porque o Java faz as contas e vai armazenando sempre no maior tipo que 
apareceu durante as operações, no caso o %%double%%. 

E, uma observação: no mínimo, o Java armazena o resultado em um %%int%%, na hora de fazer as contas.

Até casting com variáveis do tipo %%char%% podem ocorrer. O único tipo primitivo que não pode ser 
atribuído a nenhum outro tipo é o %%boolean%%.
[/box]

[box Castings possíveis]
Abaixo estão relacionados todos os casts possíveis na linguagem Java, mostrando a conversão 
**de** um valor **para** outro. A indicação **Impl.** quer dizer que aquele cast é implícito e 
automático, ou seja, você não precisa indicar o cast explicitamente (lembrando que o tipo boolean 
não pode ser convertido para nenhum outro tipo).
 
[img images/variaveis-primitivas-controle-fluxo/casting.png w=70%]

[/box]

[box Tamanho dos tipos]
Na tabela abaixo, estão os tamanhos de cada tipo primitivo do Java.

[img images/variaveis-primitivas-controle-fluxo/tamanho_tipos.png w=60%]
[/box]

[section O If-Else]
[index IF]
A sintaxe do %%if%% no Java é a seguinte:

[code java]
if (condicaoBooleana) {
	codigo;
}
[/code]

[index CONDIÇÃO BOOLEANA]
Uma **condição booleana** é qualquer expressão que retorne %%true%% ou %%false%%. Para isso, você
pode usar os operadores %%<%%, %%>%%, %%<=%%, %%>=%% e outros. Um exemplo:

[code java]
int idade = 15;
if (idade < 18) {
	System.out.println("Não pode entrar");
}
[/code]

[index ELSE]
Além disso, você pode usar a cláusula %%else%% para indicar o comportamento que deve ser executado 
no caso da expressão booleana ser falsa:

[code java]
int idade = 15;
if (idade < 18) {
	System.out.println("Não pode entrar");
} else {
	System.out.println("Pode entrar");
}
[/code]

[index OPERADORES LÓGICOS]
Você pode concatenar expressões booleanas através dos operadores lógicos **"E"** e **"OU"**. 
O **"E"** é representado pelo %%&&%% e o **"OU"** é representado pelo %%||%%.

Um exemplo seria verificar se ele tem menos de 18 anos **e** se ele não é amigo do dono:

[code java]
int idade = 15;
boolean amigoDoDono = true;
if (idade < 18 && amigoDoDono == false) {
	System.out.println("Não pode entrar");
}
else {
	System.out.println("Pode entrar");
}
[/code]

[index OPERADOR DE NEGAÇÃO]
Esse código poderia ficar ainda mais legível, utilizando-se o operador de negação, o %%!%%. 
Esse operador transforma o resultado de uma expressão booleana de %%false%% para %%true%% e vice 
versa.

[code java #]
int idade = 15;
boolean amigoDoDono = true;
if (idade < 18 && !amigoDoDono) {
	System.out.println("Não pode entrar");
}
else {
	System.out.println("Pode entrar");
}
[/code]

Repare na linha 3 que o trecho %%amigoDoDono == false%%  virou %%!amigoDoDono%%. **Eles 
têm o mesmo valor.**

Para comparar se uma variável tem o **mesmo valor** que outra variável ou valor, utilizamos 
o operador %%==%%. Repare que utilizar o operador %%=%% dentro de um %%if%% vai retornar um 
erro de compilação, já que o operador %%=%% é o de atribuição.

[code java]
int mes = 1;
if (mes == 1) {
	System.out.println("Você deveria estar de férias");
}
[/code]

[section O While]

[index LAÇO]
[index WHILE]
O %%while%% é um comando usado para fazer um **laço (loop)**, isto é, repetir um trecho de código 
algumas vezes. A idéia é que esse trecho de código seja repetido enquanto uma determinada condição 
permanecer verdadeira.

[code java]
int idade = 15;
while (idade < 18) {
	System.out.println(idade);	
	idade = idade + 1;
}
[/code]

O trecho dentro do bloco do %%while%% será executado até o momento em que a condição %%idade < 18%% 
passe a ser falsa. E isso ocorrerá exatamente no momento em que %%idade == 18%%, o que não o fará 
imprimir %%18%%.

[code java]
int i = 0;
while (i < 10) {
	System.out.println(i);	
	i = i + 1;
}
[/code]

Já o %%while%% acima imprime de 0 a 9.

[section O For]

[index FOR]
Outro comando de **loop** extremamente utilizado é o %%for%%. A idéia é a mesma do %%while%%: 
fazer um trecho de código ser repetido enquanto uma condição continuar verdadeira. Mas além 
disso, o %%for%% isola também um espaço para inicialização de variáveis e o modificador dessas 
variáveis. Isso faz com que fiquem mais legíveis, as variáveis que são relacionadas ao loop:

[code java]
for (inicializacao; condicao; incremento) {
	codigo;
}
[/code]

Um exemplo é o a seguir:

[code java]
for (int i = 0; i < 10; i = i + 1) {
	System.out.println("olá!");
}
[/code]

Repare que esse %%for%% poderia ser trocado por:

[code java]
int i = 0;
while (i < 10) {
	System.out.println("olá!");
	i = i + 1;
}
[/code]

Porém, o código do %%for%% indica claramente que a variável %%i%% serve, em especial, para 
controlar a quantidade de laços executados. Quando usar o %%for%%? Quando usar o %%while%%? 
Depende do gosto e da ocasião.

[box Pós incremento ++]
%%i = i + 1%% pode realmente ser substituído por %%i++%% quando isolado, porém, em alguns 
casos, temos essa instrução envolvida em, por exemplo, uma atribuição:

[code java]
int i = 5;
int x = i++;
[/code]

Qual é o valor de %%x%%? O de %%i%%, após essa linha, é 6.

O operador %%++%%, quando vem após a variável, retorna o valor antigo, e incrementa 
(pós incremento), fazendo %%x%% valer 5. 

Se você tivesse usado o %%++%% antes da variável (pré incremento), o resultado seria 6:

[code java]
int i = 5;
int x = ++i; // aqui x valera 6
[/code]
[/box]

[section Controlando loops]

Apesar de termos condições booleanas nos nossos laços, em algum momento, podemos decidir 
parar o loop por algum motivo especial sem que o resto do laço seja executado.

[code java]
for (int i = x; i < y; i++) {
	if (i % 19 == 0) {
		System.out.println("Achei um número divisível por 19 entre x e y");
		break;
	}
}
[/code]

[index BREAK]
O código acima vai percorrer os números de x a y e parar quando encontrar um número divisível por
19, uma vez que foi utilizada a palavra chave %%break%%.

[index CONTINUE]
Da mesma maneira, é possível obrigar o loop a executar o próximo laço. Para isso 
usamos a palavra chave %%continue%%.

[code java]
for (int i = 0; i < 100; i++) {
	if (i > 50 && i < 60) {
		continue;
	}
	System.out.println(i);
}
[/code]

O código acima não vai imprimir alguns números. (Quais exatamente?)

[section Escopo das variáveis]

No Java, podemos declarar variáveis a qualquer momento. Porém, dependendo de onde você 
as declarou, ela vai valer de um determinado ponto a outro.

[code java]
// aqui a variável i não existe
int i = 5;
// a partir daqui ela existe
[/code]

[index ESCOPO]
O **escopo da variável** é o nome dado ao trecho de código em que aquela variável existe 
e onde é possível acessá-la.

Quando abrimos um novo bloco com as chaves, as variáveis declaradas ali dentro **só valem 
até o fim daquele bloco**.

[code java]
// aqui a variável i não existe
int i = 5;
// a partir daqui ela existe
while (condicao) {
	// o i ainda vale aqui
	int j = 7;
	// o j passa a existir
}
// aqui o j não existe mais, mas o i continua dentro do escopo
[/code]

No bloco acima, a variável %%j%% pára de existir quando termina o bloco onde ela foi declarada. Se 
você tentar acessar uma variável fora de seu escopo, ocorrerá um erro de compilação.

[img images/variaveis-primitivas-controle-fluxo/cannot_find_symbol.png w=50%]

O mesmo vale para um if:

[code java]
if (algumBooleano) {
	int i = 5;
} 
else {
	int i = 10;
}
System.out.println(i); // cuidado!
[/code]

Aqui a variável %%i%% não existe fora do %%if%% e do %%else%%! Se você declarar a variável 
antes do %%if%%, vai haver outro erro de compilação: dentro do %%if%% e do %%else%% a 
variável está sendo redeclarada! Então o código para compilar e fazer sentido fica:

[code java]
int i;
if (algumBooleano) {
	i = 5;
} 
else {
	i = 10;
}
System.out.println(i);
[/code]

Uma situação parecida pode ocorrer com o %%for%%:

[code java]
for (int i = 0; i < 10; i++) {
	System.out.println("olá!");
}
System.out.println(i); // cuidado!
[/code]

Neste %%for%%, a variável %%i%% morre ao seu término, não podendo ser acessada de fora do %%for%%, 
gerando um erro de compilação. Se você realmente quer acessar o contador depois do loop 
terminar, precisa de algo como:

[code java]
int i;
for (i = 0; i < 10; i++) {
	System.out.println("olá!");
}
System.out.println(i);
[/code]

[section Um bloco dentro do outro]
Um bloco também pode ser declarado dentro de outro. Isto é, um %%if%% dentro de um %%for%%, 
ou um %%for%% dentro de um %%for%%, algo como:

[code java]
while (condicao) {
	for (int i = 0; i < 10; i++) {
		// código
	}
}
[/code]

[section Para saber mais]
[list number]
* Vimos apenas os comandos mais usados para controle de fluxo. O Java ainda possui o %%do..while%% 
e o %%switch%%. Pesquise sobre eles e diga quando é interessante usar cada um deles.

* Algumas vezes, temos vários laços encadeados. Podemos utilizar o %%break%% para quebrar o laço mais 
interno. Mas, se quisermos quebrar um laço mais externo, teremos de encadear diversos ifs e seu 
código ficará uma bagunça. O Java possui um artifício chamado **labeled loops**; pesquise sobre eles.

* O que acontece se você tentar dividir um número inteiro por 0? E por 0.0?

* Existe um caminho entre os tipos primitivos que indicam se há a necessidade ou não de casting 
entre os tipos. Por exemplo, %%int%% -> %%long%% -> %%double%% (um %%int%% pode ser tratado como um 
%%double%%, mas não o contrário). Pesquise (ou teste), e posicione os outros tipos primitivos 
nesse fluxo.

* Além dos operadores de incremento, existem os de decremento, como %%--i%% e %%i--%%. Além desses, 
você pode usar instruções do tipo %%i += x%% e %%i -= x%%, o que essas instruções fazem? Teste.
[/list]

[section Exercícios: Fixação de sintaxe]

Mais exercícios de fixação de sintaxe. Para quem já conhece um pouco de Java, pode ser muito simples; 
mas recomendamos fortemente que você faça os exercícios para se acostumar com erros de compilação, 
mensagens do javac, convenção de código, etc...
 
Apesar de extremamente simples, precisamos praticar a sintaxe que estamos aprendendo. Para cada 
exercício, crie um novo arquivo com extensão **.java**, e declare aquele estranho cabeçalho, dando nome 
a uma classe e com um bloco %%main%% dentro dele:
 
[code java]
class ExercicioX {
	public static void main(String[] args) {
		// seu exercicio vai aqui
	}
}
[/code]

Não copie e cole de um exercício já existente! Aproveite para praticar.

[exercise]
[question]
Imprima todos os números de 150 a 300.
[answer]
[code java]
class ImprimeIntervalo {
	public static void main(String[] args) {
		int i = 150;
		while (i<=300){
			System.out.println(i);
			i++;
		}
	}
}
[/code]
ou
[code java]
class ImprimeIntervalo {
	public static void main(String[] args) {
		for (int i = 150; i<=300; i++){
			System.out.println(i);
		}
	}
}
[/code]
[/answer]
[/question]
[question]
Imprima a soma de 1 até 1000.
[note]Mostre também a solução com soma de progressão aritmética.[/note]

[answer]
[code java]
class ImprimeSoma {
	public static void main(String[] args) {
		int soma = 0;
		int i = 1;
		while (i<=1000){
			soma = soma + i;
		}
		System.out.println(i);
	}
}
[/code]
ou
[code java]
class ImprimeSoma {
	public static void main(String[] args) {
		soma = 0;
		for (int i = 1; i<=1000; i++){
			soma = soma + i;
		}
		System.out.println(i);
	}
}
[/code]
[/answer]
[/question]
[question]
	Imprima todos os múltiplos de 3, entre 1 e 100.
	
	[note]
	A maioria procura multiplos olhando pro resto (%). Mostrar um que faz incremento de 3 em 3.
	[/note]
[/question]
[question]
Imprima os fatoriais de 1 a 10.

O fatorial de um número n é n * n-1 * n-2 ... até n = 1. Lembre-se de utilizar os parênteses.

O fatorial de 0 é 1

O fatorial de 1 é (0!) * 1 = 1

O fatorial de 2 é (1!) * 2 = 2

O fatorial de 3 é (2!) * 3 = 6

O fatorial de 4 é (3!) * 4 = 24

Faça um for que inicie uma variável n (número) como 1 e fatorial (resultado) como 1 e varia n 
de 1 até 10:

[code java]
for (int n = 1, fatorial = 1; n <= 10; n++) {
	
}
[/code]

[answer]
[code java]
class ImprimeFatorial {
	public static void main(String[] args) {
		for (int n = 1, fatorial = 1; n <= 10; n++) {
			fatorial = fatorial * n;
			System.out.println("Fatorial de " + n + " é: " + fatorial);
		}
	}
}
[/code]
[/answer]
[/question]
[question]
No código do exercício anterior, aumente a quantidade de números que terão os fatoriais impressos, até 20, 30, 40. 
Em um  determinado momento, além desse cálculo demorar, vai começar a mostrar respostas 
completamente erradas. Porque? Mude de %%int%% para %%long%%, e você poderá ver alguma mudança.
[answer]
Isso acontece porque, a partir de 16!, o valor supera o limite superior do tipo %%int%%. O tipo 
%%long%% consegue armazenar o cálculo dos fatoriais até 34!. Teste!
[/answer]
[/question]
[question]
(opcional) Imprima os primeiros números da série de Fibonacci até passar de 100. A série de 
Fibonacci é a seguinte: 0, 1, 1, 2, 3, 5, 8, 13, 21, etc... Para calculá-la, o primeiro elemento 
vale 0, o segundo vale 1, daí por diante, o n-ésimo elemento vale o (n-1)-ésimo elemento somado 
ao (n-2)-ésimo elemento (ex: 8 = 5 + 3).
[answer]
[code java]
class CalculaFibonacci {
	public static void main(String[] args) {
		int a = 0;
		int b = 1;
		while (b < 100) {
			int fibonacci = a + b;
			a = b;
			b = fibo;
			System.out.println(fibonacci);
		}
	}
}
[/code]
[/answer]
[/question]
[question]
(opcional) Escreva um programa que, dada uma variável %%x%% (com valor %%180%%, por exemplo), temos 
um novo %%x%% de acordo com a seguinte regra:
[list]
* se %%x%% é par, %%x = x / 2%%
* se %%x%% é impar, %%x = 3 * x + 1%%
* imprime %%x%%
* O programa deve parar quando %%x%% tiver o valor final de
1. Por exemplo, para %%x = 13%%, a saída será:

40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
[/list]
[box Imprimindo sem pular linha]
Um detalhe importante é que uma quebra de linha é impressa toda vez que chamamos %%println%%. 
Para não pular uma linha, usamos o código a seguir:

	[code]
		System.out.print(variavel);
	[/code]
[/box]

[answer]
[code java]
class TresNMaisUm {
	public static void main(String[] args) {
		int x = 13;
		do {
			if (x % 2 == 0) {
				x = x / 2;
				System.out.println("dividindo por 2");
			} else {
				x = 3 * x + 1;
				System.out.println("multiplicando por 3 e somando 1");
			}
			System.out.println(x);
		} while (x != 1);
	}
}
[/code]
Curiosamente, essa é a famosa conjectura de Collatz. Ninguém nunca
conseguiu demonstrar que sempre vai cair em um desses casos até convergir
a 1.

Parece que acabaram de prova-la:
http://preprint.math.uni-hamburg.de/public/papers/hbam/hbam2011-09.pdf
[/answer]
[/question]
[question]
(opcional)  Imprima a seguinte tabela, usando %%for%%s encadeados:
[code]
1
2 4
3 6 9
4 8 12 16
n n*2 n*3 .... n*n
[/code]
[answer]
[code java]
class Triangulo {
	public static void main(String[] args) {
		int n = 5;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= i; j++) {
				System.out.print(i * j + " ");
			}
			System.out.println();
		}
	}
}
[/code]
[/answer][/question]
[/exercise]

[section Desafios: Fibonacci]
[exercise]
[question]
Faça o exercício da série de Fibonacci usando apenas duas variáveis.
[answer]
[code java]
class Desafio {
	public static void main(String[] args) {
		int a = 0;
		int b = 1;
		while (b < 100) {
			b = a + b;
			a = b - a;
			System.out.println(b);
		}
	}
}
[/code]
[/answer]
[/question]
[/exercise]
