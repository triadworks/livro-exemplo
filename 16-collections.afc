[chapter Collections framework]
[quote "A amizade é um contrato segundo o qual nos comprometemos a prestar
pequenos favores para que no-los retribuam com grandes." 
		-- Baron de la Brede et de Montesquieu]

Ao término desse capítulo, você será capaz de:
[list]
	* utilizar arrays, lists, sets ou maps dependendo da necessidade do programa;
	* iterar e ordenar listas e coleções;
	* usar mapas para inserção e busca de objetos.
[/list]

[note]
* faça com que eles abram o javadoc do java.util para eles acompanharem a documentação das classes
* não dar muitas explicacoes sobre um Hash. Explicar que é uma indexação, e que _HashSet_ é 
centenas de vezes mais rápido de procurar que uma _ArrayList_ (exemplo do método _contains_).
No maximo faca analogia a indexacao por primeira letra... e cite que é uma tabela de espalhamento
no  caso de alguem conhecer da faculdade.
* as pessoas tem dificuldade com generics, com _Map<K,V>_ que recebe dois tipos parametrizados fica pior ainda.
* passar rapidamente pelo _Iterator_ se achar necessário. Senão vá apenas pelo enhanced for e 
explique que ele usa internamente um _Iterator_, que era a unica forma antigamente
* Comparable é um excelente exemplo de uso de interfaces. Mostre que quem criou Collections 
nunca imaginou que iria comparar a classe _ContaCorrente_. Empolgue-os!
* Comentar a classe Vector, mas dizer que nao se usa mais. (talvez nem comentar)
* So cite a interface Collection DEPOIS de ter apresentado Set. A ordem é: ArrayList,
LinkedList, depois mostra que elas implementam LIST, depois fala um pouco de Set e ai
entao mostra a super interface.
[/note]

[note]
Para a galera amadurecer no uso de interfaces: (ir bem devagar na explicação)
Foi requisitado q nossa equipe modelasse a classe Banco q possui várias
Contas. Como só conhecemos array para o trabalho vamos usar array mesmo...
Precisamos adicionar contas no banco e remover por índice.

[code java]
class Banco {
	private Conta[] contas = new Conta[100];
	public void adiciona(Conta conta) { 
		//fazer na lousa, aumentando o tamanho se necessário
	public void remove(int indice) {
		//discutir o shifting para não só jogar referencia pra null
		//o objetivo é mostrar a dificuldade de trabalhar com arrays mesmo!
}
[/code]

Questionar o q vai aparecer na Javadoc de nossa classe. Se precisarmos mudar
a implementação e usar algo diferente de array haverá algum impacto para quem
estiver utilizando o Banco? (usar a classe Banco em um main() )
Antes de colocarmos nossa classe em produção foi pedido q a lista de contas
fosse devolvida para que pudesse ser mostrada em uma tabela em um aplicativo web.

Colocar getter na classe Banco.
E agora quem for usar nossa classe sabe q usamos array?
No main o uso da classe banco:
[code java]
	...
	Conta[] contas = banco.getContas();
	//usando o array na criação da tabela	
	???primeiraLinha=contas[0]; ...
[/code]

E se decidirmos depois usar um tipo diferente vai haver problema?
Então antes de mandarmos a classe pra produção vamos pesquisar um pouco? Apresentar o 
ArrayList (sem comentar da interface ainda!). Usar fora do contexto do problema,
em um main() trabalhando apenas com String, mostrando as vantagens. Depois mudar o uso
do array em banco para ArrayList<Conta>. (Já usando generics direto)
Mudar o tipo de retorno do getContas para ArrayList<Conta> e perguntar se
agora nossa classe está pronta.

Falar q mais tarde o pessoal criou alguns botões na tabela (q era só pra visualização) e
começou a ter muita remoção por índice. Com muitas contas o sistema ficou lento para essas
operações. Falar da LinkedList e da diferença entre ela e o ArrayList. E agora para mudarmos?

No main o uso da classe banco:
[code java]
	...
	ArrayList<Conta> contas = banco.getContas();
	//usando a lista na criação da tabela	
	???primeiraLinha=contas.get(0); ...
[/code]

Falar da interface List e mudar o tipo de retorno do getContas() para List. Comentar se tivessemos
feito isso no começo seria fácil a mudança. (Fica bem claro isso pra galera)

Em turmas (MUITO?) fortes dá pra arriscar motivar tb o uso de generics: Mostrar fora do contexto de nossa
classe o problema de usar coleções não assinadas e perguntar se é problema pra nós (o método adiciona
garante que só haverá contas em nossa coleção?).
[code java]
...
List contas = banco.getContas();
contas.add("Nome");	
[/code]

Mudar o retorno pra List<Conta> (q não impede referenciarmos pelo raw type...). O problema de mostrar a
quebra de encapsulamento (especialmente se há alguma lógica no adiciona(Conta c) é ficar encurralado
a falar do unmodifiableList).
[/note]

[section Arrays são trabalhosos, utilizar estrutura de dados]
Como vimos no capítulo de arrays, manipulá-las é bastante trabalhoso. Essa dificuldade
aparece em diversos momentos:

[list]
	* não podemos redimensionar um array em Java;
	* é impossível buscar diretamente por um determinado elemento cujo índice não se sabe;
	* não conseguimos saber quantas posições do array já foram populadas sem criar, para isso, 
métodos auxiliares.
[/list]

[img images/collections/array1.png w=50]

Na figura acima, você pode ver um array que antes estava sendo completamente utilizado e que, depois, 
teve um de seus elementos removidos.

Supondo que os dados armazenados representem contas, o que acontece quando precisarmos inserir uma 
nova conta no banco? Precisaremos procurar por um espaço vazio? Guardaremos em alguma estrutura de
dados externa, as posições vazias? E se não houver espaço vazio? Teríamos de criar um array maior
e copiar os dados do antigo para ele? 

Há mais questões: como posso saber quantas posições estão sendo usadas no array? Vou precisar sempre 
percorrer o array inteiro para conseguir essa informação?

Além dessas dificuldades que os arrays apresentavam, faltava um conjunto robusto de classes para 
suprir a necessidade de estruturas de dados básicas, como listas ligadas e tabelas de espalhamento.

[index COLLECTIONS]
Com esses e outros objetivos em mente, a Sun criou um conjunto de classes e interfaces conhecido como 
**Collections Framework**, que reside no pacote %%java.util%% desde o Java2 1.2.

[box Collections]
A **API** do **Collections** é robusta e possui diversas classes que representam estruturas de dados 
avançadas.

Por exemplo, não é necessário reinventar a roda e criar uma lista ligada, mas sim utilizar aquela que 
a Sun disponibilizou.
[/box]

[section Listas: java.util.List]
Um primeiro recurso que a API de %%Collections%% traz são **listas**. Uma lista é uma coleção que 
permite elementos duplicados e mantém uma ordenação específica entre os elementos.

Em outras palavras, você tem a garantia de que, quando percorrer a lista, os elementos serão 
encontrados em uma ordem pré-determinada, definida na hora da inserção dos mesmos.

Ela resolve todos os problemas que levantamos em relação ao array (busca, remoção, tamanho 
"infinito",...). Esse código já está pronto!

A API de %%Collections%% traz a interface %%java.util.List%%, que especifica o que uma classe deve 
ser capaz de fazer para ser uma lista. Há diversas implementações disponíveis, cada uma com uma forma 
diferente de representar uma lista.

A implementação mais utilizada da interface %%List%% é a %%ArrayList%%, que trabalha com um array 
interno para gerar uma lista. Portanto, ela é mais rápida na pesquisa do que sua concorrente, a 
%%LinkedList%%, que é mais rápida na inserção e remoção de itens nas pontas.

[box ArrayList não é um array!]
É comum confundirem uma %%ArrayList%% com um array, porém ela não é um array. O que ocorre é que, 
internamente, ela usa um array como estrutura para armazenar os dados, porém este atributo está 
propriamente encapsulado e você não tem como acessá-lo. Repare, também, que você não pode usar 
%%[]%% com uma %%ArrayList%%, nem acessar atributo %%length%%. Não há relação!
[/box]

Para criar um %%ArrayList%%, basta chamar o construtor:

[code java]
	ArrayList lista = new ArrayList();
[/code]

[note]
Nao mostre logo de cara que ArrayList é uma List. Acho melhor
mostrar vantagens e desvantagens em relacao a velocidade com a LinkedList
e deixar os alunos em duvida de qual usar.

Ai voce solta um "Pra que se importar com isso agora? Vamos nos
desacoplar disso... programar voltado a INTERFACE" e entao apresente
a interface List.
[/note]

É sempre possível abstrair a lista a partir da interface %%List%%:

[code java]
	List lista = new ArrayList();
[/code]


Para criar uma lista de nomes (%%String%%), podemos fazer:

[code java]
	List lista = new ArrayList();
	lista.add("Manoel");
	lista.add("Joaquim");
	lista.add("Maria");
[/code]

A interface %%List%% possui dois métodos %%add%%, um que recebe o objeto a ser inserido e o coloca 
no final da lista, e um segundo que permite adicionar o elemento em qualquer posição da mesma.

Note que, em momento algum, dizemos qual é o tamanho da lista; podemos acrescentar quantos elementos 
quisermos, que a lista cresce conforme for necessário.

Toda lista (na verdade, toda %%Collection%%) trabalha do modo mais genérico possível. Isto é, não há 
uma %%ArrayList%% específica para %%Strings%%, outra para Números, outra para Datas etc. **Todos os 
métodos trabalham com %%Object%%**.

[note]
Aqui o instrutor tem liberdade de mostrar os métodos que achar mais interessante na lousa. remove,
add, get, contains são bem interessantes. Cuidado com o get() pois ele devolve object
enquanto voce ainda nao apresentar generics (logo a seguir).
[/note]


Assim, é possível criar, por exemplo, uma lista de Contas Correntes:

[code java]
	ContaCorrente c1 = new ContaCorrente();
	c1.deposita(100);

	ContaCorrente c2 = new ContaCorrente();
	c2.deposita(200);

	ContaCorrente c3 = new ContaCorrente();
	c3.deposita(300);

	List contas = new ArrayList();
	contas.add(c1);
	contas.add(c3);
	contas.add(c2);
[/code]

Para saber quantos elementos há na lista, podemos usar o método %%size()%%:

[code java]
	System.out.println(contas.size());
[/code]

Há ainda um método %%get(int)%% que recebe como argumento o índice do elemento que se quer 
recuperar. Através dele, podemos fazer um %%for%% para iterar na lista de contas:

[code java]
	for (int i = 0; i < contas.size(); i++) {
		contas.get(i); // código não muito útil....
	}
[/code]

Mas como fazer para imprimir o saldo dessas contas? Podemos acessar o %%getSaldo()%% diretamente 
após fazer %%contas.get(i)%%? Não podemos; lembre-se que toda lista trabalha sempre com %%Object%%. 
Assim, a referência devolvida pelo %%get(i)%% é do tipo %%Object%%, sendo necessário o cast para 
%%ContaCorrente%% se quisermos acessar o %%getSaldo()%%:

[code java]
	for (int i = 0; i < contas.size(); i++) {
		ContaCorrente cc = (ContaCorrente) contas.get(i);
		System.out.println(cc.getSaldo());
	}
	// note que a ordem dos elementos não é alterada
[/code]

Há ainda outros métodos como %%remove()%% que recebe um objeto que se deseja remover da lista; e 
%%contains()%%, que recebe um objeto como argumento e devolve %%true%% ou %%false%%, indicando se o 
elemento está ou não na lista.

[note]
* Voce pode perguntar para os alunos o que é comum eles quererem fazer com
uma array/lista

* É uma excelente oportunidade de demonstrar conhecimento: eles perguntam e voce escreve na
lousa o metodo correspondente

* é facil induzir para que eles motivem voce a mostrar indexOf, set, contains, remove(Object),
remove(int), removeAll, addAll, etc...

* Nao deixe de dar o exemplo com o contains na lousa! Ele sera usado no exercicio.
Mais ainda, pergunte pra eles como eles acham que o contains funciona. Normalmente
alguem vai perceber e dizer que ele vai procurar se tem um elemento %%equals%% ao que
foi passado como argumento! (vale lembrar que isso nao é contrato da interface, 
tanto que IdentityHashMap procura por ==, mas ninguem nem vai perguntar isso)
[/note]

A interface %%List%% e algumas classes que a implementam podem ser vistas no diagrama **UML** a 
seguir:

[img images/collections/list.png w=75]

[box Acesso aleatório e percorrendo listas com get]
Algumas listas, como a %%ArrayList%%, têm acesso aleatório aos seus elementos: a busca por um 
elemento em uma determinada posição é feita de maneira imediata, sem que a lista inteira seja 
percorrida (que chamamos de acesso sequencial).

Neste caso, o acesso através do método %%get(int)%% é muito rápido. Caso contrário, 
percorrer uma lista usando um %%for%% como esse que acabamos de ver, pode ser desastroso. Ao 
percorrermos uma lista, devemos usar **sempre** um %%Iterator%% ou %%enhanced for%%, como veremos.
[/box]

Uma lista é uma excelente alternativa a um array comum, já que temos todos os benefícios de arrays, 
sem a necessidade de tomar cuidado com remoções, falta de espaço etc.

A outra implementação muito usada (%%LinkedList%%), fornece métodos adicionais para obter e remover 
o primeiro e último elemento da lista. Ela também tem o funcionamento interno diferente,
o que pode impactar performance, como veremos durante os exercícios no final do capítulo.
 
[box Vector]
Outra implementação é a tradicional classe %%Vector%%, presente desde o Java 1.0, que foi adaptada 
para uso com o framework de Collections, com a inclusão de novos métodos.

Ela deve ser tratada com cuidado pois lida de uma maneira diferente com processos correndo em 
paralelo e será mais lenta que uma %%ArrayList%% quando não houver acesso simultâneo aos dados.
[/box]

[section Listas no Java 5.0 com Generics]
Em qualquer lista, é possível colocar qualquer %%Object%%. Com isso, é possível misturar objetos:

[code java]
	ContaCorrente cc = new ContaCorrente();
	
	List lista = new ArrayList();
	lista.add("Uma string");
	lista.add(cc);
	...
[/code]

Mas e depois, na hora de recuperar esses objetos? Como o método %%get%% devolve um %%Object%%, 
precisamos fazer o cast. Mas com uma lista com vários objetos de tipos diferentes, isso pode não ser 
tão simples...

Geralmente, não nos interessa uma lista com vários tipos de objetos misturados; no dia-a-dia, usamos 
listas como aquela de contas correntes. No Java 5.0, podemos usar o recurso de Generics para 
restringir as listas a um determinado tipo de objetos (e não qualquer %%Object%%):

[code java]
	List<ContaCorrente> contas = new ArrayList<ContaCorrente>();
	contas.add(c1);
	contas.add(c3);
	contas.add(c2);
[/code]

Repare no uso de um parâmetro ao lado de %%List%% e %%ArrayList%%: ele indica que nossa lista foi 
criada para trabalhar exclusivamente com objetos do tipo %%ContaCorrente%%. Isso nos traz uma 
segurança em tempo de compilação:

[code java]
	contas.add("uma string"); // isso não compila mais!!
[/code]

O uso de Generics também elimina a necessidade de casting, já que, seguramente, todos os objetos 
inseridos na lista serão do tipo %%ContaCorrente%%:

[code java]
	for(int i = 0; i < contas.size(); i++) {
		ContaCorrente cc = contas.get(i); // sem casting!
		System.out.println(cc.getSaldo());
	}
[/code]

[section A importância das interfaces nas coleções]

[note]
* Importantissimo frisar a elegancia do design das collections!
* Volte a falar de como o Tributavel nos ajudou, de como Connection
é legal, e já é um preparo para Comparable.
* interface versus implementacao novamente
* eles verao no exercicio como isso vai ajudar em performance, apesar
de nao ser unica vantagem, mas isso enche os olhos dos alunos!
[/note]

Vale ressaltar a importância do uso da interface %%List%%: quando desenvolvemos,
procuramos sempre nos referir a ela, e não às implementações específicas. Por exemplo,
se temos um método que vai buscar uma série de contas no banco de dados, poderíamos
fazer assim:

[code java]
class Agencia {
	public ArrayList<Conta> buscaTodasContas() {
		ArrayList<Conta> contas = new ArrayList<Conta>();

		// para cada conta do banco de dados, contas.add
		
		return contas;
	}
}
[/code]

Porém, para que precisamos retornar a referência específica a uma %%ArrayList%%?
Para que ser tão específico? Dessa maneira, o dia que optarmos por devolver 
uma %%LinkedList%% em vez de %%ArrayList%%, as pessoas que estão usando o método
%%buscaTodasContas%% poderão ter problemas, pois estavam fazendo referência
a uma %%ArrayList%%. O ideal é sempre trabalhar com a interface mais genérica possível:

[code java]
class Agencia {

	// modificacao apenas no retorno:
	public List<Conta> buscaTodasContas() {
		ArrayList<Conta> contas = new ArrayList<Conta>();

		// para cada conta do banco de dados, contas.add
		
		return contas;
	}
}
[/code]

É o mesmo caso de preferir referenciar aos objetos com %%InputStream%% como fizemos
no capítulo passado.

[note]
Esse momento é bastante importante. É fundamental para o aprendizado dos alunos
que eles saim do FJ11 com a certeza que o uso de interface desacopla bastante
o codigo deles. Eles verao mais disso a seguir, com Comparable.
[/note]

Assim como no retorno, é boa prática trabalhar com a interface em
todos os lugares possíveis: métodos que precisam receber uma lista
de objetos têm %%List%% como parâmetro em vez de uma
implementação em específico como %%ArrayList%%, deixando o método
mais flexível:

[code java]
class Agencia {

	public void atualizaContas(List<Conta> contas) {
		// ...
	}
}
[/code]

[note]
Aqui seria melhor receber List<? extends Conta>, porem entrar na discussao
do wildcard no FJ11 é loucura.
[/note]
 
Também declaramos atributos como %%List%%
em vez de nos comprometer como uma ou outra implementação. Dessa
forma obtemos um **baixo acoplamento**: podemos trocar a implementação,
já que estamos programando para a interface! Por exemplo:

[code java]
class Empresa {

	private List<Funcionario> empregados = new ArrayList<Funcionario>();

	// ...
}
[/code]

[section Ordenação: Collections.sort]

Vimos anteriormente que as listas são percorridas de maneira pré-determinada de
acordo com a inclusão dos itens. Mas, muitas vezes, queremos percorrer a nossa
lista de maneira ordenada.

A classe %%Collections%% traz um método estático %%sort%% que recebe um %%List%%
como argumento e o ordena por ordem crescente. Por exemplo:

[code java]
   List lista = new ArrayList();
   lista.add("Sérgio");
   lista.add("Paulo");
   lista.add("Guilherme");

   System.out.println(lista); //repare que o toString de ArrayList foi sobrescrito!

   Collections.sort(lista);

   System.out.println(lista);
[/code]

Ao testar o exemplo acima, você observará que, primeiro, a lista é impressa na
ordem de inserção e, depois de invocar o %%sort%%, ela é impressa em ordem alfabética.

Mas toda lista em Java pode ser de qualquer tipo de objeto, por exemplo, 
%%ContaCorrente%%. E se quisermos ordenar uma lista de %%ContaCorrente%%? Em que
ordem a classe %%Collections%% ordenará? Pelo saldo? Pelo nome do correntista?

[code java]
	ContaCorrente c1 = new ContaCorrente();
	c1.deposita(500);

	ContaCorrente c2 = new ContaCorrente();
	c2.deposita(200);

	ContaCorrente c3 = new ContaCorrente();
	c3.deposita(150);

	List<ContaCorrente> contas = new ArrayList<ContaCorrente>();
	contas.add(c1);
	contas.add(c3);
	contas.add(c2);

	Collections.sort(contas); // qual seria o critério para esta ordenação?
[/code]

Sempre que falamos em ordenação, precisamos pensar em um **critério de ordenação**,
uma forma de determinar qual elemento vem antes de qual. É necessário instruir
o %%sort%% sobre como **comparar** nossas %%ContaCorrente%% a fim de determinar 
uma ordem na lista. Para isto, o método %%sort%% necessita que todos seus objetos
da lista sejam **comparáveis** e possuam um método que se compara com outra 
%%ContaCorrente%%. Como é que o método %%sort%% terá a garantia de que a sua 
classe possui esse método? Isso será feito, novamente, através de um contrato, 
de uma interface!

[note]
Aqui é bem importante fazer eles raciocinarem e chegarem a conclusão de usar uma interface.
Voce deve mostrar o codigo para ordenar a %%List<ContaCorrente>%% e então perguntar como
comparar duas contas. Depois de decidido que vai ser através de um método, deve perguntar
"e como o autor do %%Collections.sort%% vai saber o nome e assinatura do metodo que deve
invocar dos seus objetos?"
[/note]


[index COMPARABLE]
Vamos fazer com que os elementos da nossa coleção implementem a interface 
%%java.lang.Comparable%%, que define o método %%int compareTo(Object)%%. Este 
método deve retornar **zero**, se o objeto comparado for **igual** a este objeto,
um número **negativo**, se este objeto for **menor** que o objeto dado, e um 
número **positivo**, se este objeto for **maior** que o objeto dado.

Para ordenar as %%ContaCorrente%%s por saldo, basta implementar o %%Comparable%%:

[code java]
    public class ContaCorrente extends Conta implements Comparable<ContaCorrente> {

	    // ... todo o codigo anterior fica aqui

	    public int compareTo(ContaCorrente outra) {

	      if (this.saldo < outra.saldo) {
	        return -1;
	      }

	      if (this.saldo > outra.saldo) {
	        return 1;
	      }

	      return 0;
	    }
    }
[/code]

Com o código anterior, nossa classe tornou-se "**comparável**": dados dois objetos da classe, 
conseguimos dizer se um objeto é maior, menor ou igual ao outro, segundo algum critério por nós 
definido. No nosso caso, a comparação será feita baseando-se no saldo da conta.

Repare que o critério de ordenação é totalmente aberto, definido pelo programador. Se quisermos 
ordenar por outro atributo (ou até por uma combinação de atributos), basta modificar a implementação 
do método %%compareTo%% na classe.

Quando chamarmos o método %%sort%% de %%Collections%%, ele saberá como fazer a ordenação 
da lista; ele usará o critério que definimos no método %%compareTo%%.

Mas, e o exemplo anterior, com uma lista de Strings? Por que a ordenação funcionou, naquele caso, sem 
precisarmos fazer nada? Simples: quem escreveu a classe %%String%% (lembre que ela é uma classe 
como qualquer outra) implementou a interface %%Comparable%% e o método %%compareTo%% para %%String%%s, 
fazendo comparação em ordem alfabética. (Consulte a documentação da classe %%String%% e veja o método 
%%compareTo%% lá). O mesmo acontece com outras classes como %%Integer%%, %%BigDecimal%%, %%Date%%,
entre outras.

[box Definindo outros critérios de ordenação]
É possível definir outros critérios de ordenação usando um objeto do tipo %%Comparator%%. Existe um 
método %%sort%% em %%Collections%% que recebe, além da %%List%%, um %%Comparator%% definindo um 
critério de ordenação específico. É possível ter vários %%Comparator%%s com critérios diferentes 
para usar quando for necessário.
[/box]

[box Outros métodos da classe Collections]
A classe %%Collections%% traz uma grande quantidade de métodos estáticos úteis na manipulação de coleções.

[list]
* %%binarySearch(List, Object)%%: Realiza uma busca binária por determinado elemento na lista ordenada 
e retorna sua posição ou um número negativo, caso não encontrado.

* %%max(Collection)%%: Retorna o maior elemento da coleção.

* %%min(Collection)%%: Retorna o menor elemento da coleção.

* %%reverse(List)%%: Inverte a lista.

* ...e muitos outros. Consulte a documentação para ver outros metódos.
[/list]

Existe uma classe análoga, a %%java.util.Arrays%%, que faz operações similares com arrays.

É importante conhecê-las para evitar escrever código já existente.
[/box]

[section Exercícios: Ordenação]

[note]
	É muito interessante eles aprenderem sobre a API, mas mais ainda é que eles
	consigam enxergar que todos os conceitos aprendidos até agora de OO serao
	aplicados nesse exercicio: em especial muito o uso de interfaces e como
	isso desacopla codigo.
[/note]

[exercise]
	[question]
		Abra sua classe %%Conta%% e veja se ela possui o atributo %%numero%%. Se não possuir,
		adicione-o:
		
		[code java]
		private int numero;
		[/code]
		
		E gere o getter e o setter pelo Eclipse, caso necessário.
	[/question]
	[question]
		Faça sua classe %%ContaPoupanca%% implementar a interface %%Comparable<ContaPoupanca>%%. 
		Utilize o critério de ordenar pelo número da conta ou pelo seu saldo (como visto no código 
		deste capítulo).
		
		[code java]
			public class ContaPoupanca extends Conta implements Comparable<ContaPoupanca>{
				...
			}
		[/code]
		
		Repare que o Eclipse prontamente lhe oferecerá um quickfix, oferecendo a criação do 
		esqueleto dos métodos definidos na interface %%Comparable%%:
		
		[img images/collections/comparable.png w=100]
		
		Deixe o seu método %%compareTo%% parecido com este:
		
		[code java]
			public class ContaPoupanca extends Conta
						implements Comparable<ContaPoupanca> {
		
				// ... todo o codigo anterior fica aqui
		
				public int compareTo(ContaPoupanca o) {
					if (this.getNumero() < o.getNumero()) {
						return -1;
					} 
					if (this.getNumero() > o.getNumero()) {
						return 1;
					} 
					return 0;
			    }
		    }
		[/code]
		
		[box Outra implementação...]
		O que acha da implementação abaixo?
		
		[code java]
		public int compareTo(ContaPoupanca outra) {
				  return this.getNumero() - outra.getNumero();
		}
		[/code]
		[/box]
	[/question]
	
	[question]
		Crie uma classe %%TestaOrdenacao%%, onde você vai instanciar diversas contas e adicioná-las a 
		uma %%List<ContaPoupanca>%%. Use o %%Collections.sort()%% nessa lista:
		
		[code java]
			public class TestaOrdenacao {
		
				public static void main(String[] args) {
		
					List<ContaPoupanca> contas = new ArrayList<ContaPoupanca>();
		
					ContaPoupanca c1 = new ContaPoupanca();
					c1.setNumero(1973);
					contas.add(c1);
		
					ContaPoupanca c2 = new ContaPoupanca();
					c2.setNumero(1462);
					contas.add(c2);
		
					ContaPoupanca c3 = new ContaPoupanca();
					c3.setNumero(1854);
					contas.add(c3);
			
					Collections.sort(contas);	
				}
			}
		[/code]
		
		Faça um laço para imprimir todos os números das contas na lista já ordenada:
		
		[code java]
			for (int i = 0; i < contas.size(); i++) {
				Conta atual = contas.get(i);
				System.out.println("numero: " + atual.getNumero());
			}
		[/code]		
		
		**Atenção especial**: repare que escrevemos um método %%compareTo%% em nossa classe e nosso 
		código **nunca** o invoca!! Isto é muito comum. Reescrevemos (ou implementamos) um método e
		quem o invocará será um outro conjunto de classes (nesse caso, quem está chamando o 
		%%compareTo%% é o %%Collections.sort%%, que o usa como base para o algoritmo de ordenação). 
		Isso cria um sistema extremamente coeso e, ao mesmo tempo, com baixo acoplamento: a classe 
		%%Collections%% nunca imaginou que ordenaria objetos do tipo %%ContaPoupanca%%, mas já que 
		eles são %%Comparable%%, o seu método %%sort%% está satisfeito.

		Você poderia escrever o %%for%% acima de uma maneira mais sucinta:
		
		[code java]
			for (int i = 0; i < contas.size(); i++) {
				System.out.println("numero: " + contas.get(i).getNumero());
			}
		[/code]				
	[/question]
	
	[question]
		O que teria acontecido se a classe %%ContaPoupanca%% não implementasse 
		%%Comparable<ContaPoupanca>%% mas tivesse o método %%compareTo%%? 
		
		Faça um teste: remova temporariamente a sentença %%implements Comparable<ContaPoupanca>%%,
		não remova o método %%compareTo%% e veja o que acontece. Basta ter o método, sem assinar a
		interface?
	[/question]
	
	[question]
		Utilize uma %%LinkedList%% em vez de %%ArrayList%%:
	
	[code java]		
		List<ContaPoupanca> contas = new LinkedList<ContaPoupanca>();
	[/code]		
	
		Precisamos alterar mais algum código para
		que essa substituição funcione? Rode o programa. Alguma diferença?
	
		[note]
			Essa mudanca é um pretexto pro exercicio de performance ao final do
			capitulo.
		[/note]	
	[/question]
	
	[question]
		Como posso inverter a ordem de uma lista? Como posso embaralhar
		todos os elementos de uma lista? Como posso rotacionar os elementos
		de uma lista? 
		
		Investigue a documentação da classe %%Collections%% dentro do
		pacote %%java.util%%.
	[/question]

	[question]
		(opcional) Se preferir, insira novas contas através de um laço (%%for%%). Adivinhe o nome da
		classe para colocar saldos aleatórios? %%Random%%. Do pacote %%java.util%%. Consulte sua 
		documentação para usá-la (utilize o método %%nextInt()%% passando o número máximo a ser sorteado).
	[/question]
	
	[question]
		(opcional) Imprima a referência para essa lista. Repare que o %%toString%% de uma 
		%%ArrayList%%/%%LinkedList%% é reescrito:
		
		[code java]
			System.out.println(contas);
		[/code]
	[/question]
	[question]
		(opcional) Mude o critério de comparação da sua %%ContaPoupanca%%. Adicione um atributo 
		%%nomeDoCliente%% na sua classe (caso ainda não exista algo semelhante) e tente mudar o 
		%%compareTo%% para que uma lista de %%ContaPoupanca%% seja ordenada alfabeticamente pelo atributo 
		%%nomeDoCliente%%.
		
		Teste a ordenação.
	[/question]
[/exercise]

[section Conjunto: java.util.Set]
[index SET]
Um conjunto (%%Set%%) funciona de forma análoga aos conjuntos da matemática, ele é uma coleção que 
não permite elementos duplicados. 

Outra característica fundamental dele é o fato de que a ordem em que os elementos são armazenados 
pode não ser a ordem na qual eles foram inseridos no conjunto. A interface não define como deve
ser este comportamento. Tal ordem varia de implementação para implementação.

[img images/collections/conjunto.png w=60%]
[img images/collections/set.png w=40%]

Um conjunto é representado pela interface %%Set%% e tem como suas principais implementações as 
classes %%HashSet%%, %%LinkedHashSet%% e %%TreeSet%%.

O código a seguir cria um conjunto e adiciona diversos elementos, e alguns repetidos:

[code java]
	Set<String> cargos = new HashSet<String>();
	
	cargos.add("Gerente");
	cargos.add("Diretor");
	cargos.add("Presidente");
	cargos.add("Secretária");
	cargos.add("Funcionário");
	cargos.add("Diretor"); // repetido!

	// imprime na tela todos os elementos
	System.out.println(cargos);
[/code]

Aqui, o segundo %%Diretor%% não será adicionado e o método %%add%% lhe retornará %%false%%.

O uso de um %%Set%% pode parecer desvantajoso, já que ele não armazena a ordem, e não
aceita elementos repetidos. Não há métodos que trabalham com índices, como o %%get(int)%% que
as listas possuem. A grande vantagem do %%Set%% é que existem implementações, como a %%HashSet%%,
que possui uma performance incomparável com as %%List%%s quando usado para pesquisa (método
%%contains%% por exemplo). Veremos essa enorme diferença durante os exercícios.

[box Ordem de um Set]
Seria possível usar uma outra implementação de conjuntos, como um %%TreeSet%%, que insere os 
elementos de tal forma que, quando forem percorridos, eles apareçam em uma ordem definida pelo 
método de comparação entre seus elementos. Esse método é definido pela interface 
%%java.lang.Comparable%%. Ou, ainda, pode se passar um %%Comparator%% para seu construtor.

Já o %%LinkedHashSet%% mantém a ordem de inserção dos elementos.
[/box] 

Antes do Java 5, não podíamos utilizar generics, e usávamos o %%Set%% de forma que ele
trabalhava com %%Object%%, havendo necessidade de castings.

[section Principais interfaces: java.util.Collection]
As coleções têm como base a interface %%Collection%%, que define métodos para adicionar e remover um 
elemento, e verificar se ele está na coleção, entre outras operações, como mostra a tabela a seguir: 

[img images/collections/metodos-collection.png w=90%]

Uma coleção pode implementar diretamente a interface %%Collection%%, porém normalmente se usa uma das 
duas subinterfaces mais famosas: justamente %%Set%% e %%List%%.

A interface %%Set%%, como previamente vista, define um conjunto de elementos únicos enquanto a interface %%List%% 
permite elementos duplicados, além de manter a ordem a qual eles foram adicionados.

A busca em um %%Set%% pode ser mais rápida do que em um objeto do tipo %%List%%, pois diversas 
implementações utilizam-se de tabelas de espalhamento (::hash tables::), realizando a busca para tempo 
linear (**O(1)**).

[index MAP]
A interface %%Map%% faz parte do framework, mas não estende %%Collection%%. (veremos %%Map%% mais 
adiante).

[img images/collections/collection-map.png w=60%]

No Java 5, temos outra interface filha de %%Collection%%: a %%Queue%%, que define métodos de entrada 
e de saída e cujo critério será definido pela sua implementação (por exemplo LIFO, FIFO ou ainda um 
heap onde cada elemento possui sua chave de prioridade).

[section Percorrendo coleções no Java 5]
Como percorrer os elementos de uma coleção? Se for uma lista, podemos sempre utilizar um laço 
%%for%%, invocando o método %%get%% para cada elemento. Mas e se a coleção não permitir indexação?

Por exemplo, um %%Set%% não possui um método para pegar o primeiro, o segundo ou o quinto elemento 
do conjunto, já que um conjunto não possui o conceito de "ordem"

[note]
Não há problema se voce ja mostrou o enhanced for antes com a lista. Na apostila mostramos
so aqui para ir devagar. A lousa ajuda e possibilita acelerar.
[/note]

Podemos usar o **enhanced-for** (o "foreach") do Java 5 para percorrer qualquer %%Collection%% sem
nos preocupar com isso. Internamente o compilador vai fazer com que seja usado o %%Iterator%% da %%Collection%% 
dada para percorrer a coleção. Repare:

[code java]
	Set<String> conjunto = new HashSet<String>();
	
	conjunto.add("java");
	conjunto.add("vraptor");
	conjunto.add("scala");

	for (String palavra : conjunto) {
		System.out.println(palavra);
	}
[/code]

Em que ordem os elementos serão acessados?

Numa lista, os elementos aparecerão de acordo com o índice em que foram inseridos, isto é, de acordo 
com o que foi pré-determinado. Em um conjunto, a ordem depende da implementação da interface %%Set%%:
você muitas vezes não vai saber ao certo em que ordem os objetos serão percorridos.

[note]
	Você pode fazer a analogia de uma sacola e de uma fila. Numa fila voce sabe a ordem
	e pode perguntar "quem é o terceiro da fila", já, numa sacola, não faz sentido
	perguntar "qual é o terceiro livro dentro dessa sacola".
[/note]

Por que o %%Set%% é, então, tão importante e usado?

Para perceber se um item já existe em uma lista, é muito mais rápido usar algumas implementações de %%Set%% 
do que um %%List%%, e os %%TreeSets%% já vêm ordenados de acordo com as características que desejarmos! 
Sempre considere usar um %%Set%% se não houver a necessidade de guardar os elementos em determinada
ordem e buscá-los através de um índice. 

No eclipse, você pode escrever %%foreach%% e dar **ctrl+espaço**, que ele vai gerar
o esqueleto desse enhanced for! Muito útil!

[section Para saber mais: Iterando sobre coleções com java.util.Iterator]
Antes do Java 5 introduzir o novo enhanced-for, iterações em coleções eram feitas com o %%Iterator%%.
Toda coleção fornece acesso a um ::iterator::, um objeto que implementa a interface %%Iterator%%, que 
conhece internamente a coleção e dá acesso a todos os seus elementos, como a figura abaixo mostra.

[img images/collections/iterator.png w=65%]

Ainda hoje (depois do Java 5) podemos usar o %%Iterator%%,
mas o mais comum é usar o enhanced-for. E, na verdade, o enhanced-for é apenas um açúcar sintático que
usa iterator por trás dos panos. 

[index ITERATOR]
Primeiro criamos um %%Iterator%% que entra na coleção. A cada chamada do método %%next%%, 
o %%Iterator%% retorna o próximo objeto do conjunto. Um %%iterator%% pode ser obtido com
o método %%iterator()%% de %%Collection%%, por exemplo numa lista de %%String%%:

[code java]
	Iterator<String> i = lista.iterator();
[/code]

A interface %%Iterator%% possui dois métodos principais: %%hasNext()%% (com retorno booleano), indica 
se ainda existe um elemento a ser percorrido; %%next()%%, retorna o próximo objeto.

Voltando ao exemplo do conjunto de strings, vamos percorrer o conjunto:

[code java]
	Set<String> conjunto = new HashSet<String>();
	conjunto.add("item 1");
	conjunto.add("item 2");
	conjunto.add("item 3");

	// retorna o iterator
	Iterator<String> i = conjunto.iterator();
	while (i.hasNext()) {
		// recebe a palavra
		String palavra = i.next();
		System.out.println(palavra);
	}	
[/code]

O %%while%% anterior só termina quando todos os elementos do conjunto forem percorridos, isto é, 
quando o método %%hasNext%% mencionar que não existem mais itens.

[box ListIterator]
Uma lista fornece, além de acesso a um %%Iterator%%, um %%ListIterator%%, que oferece recursos 
adicionais, específicos para listas.

Usando o %%ListIterator%%, você pode, por exemplo, adicionar um elemento na lista ou voltar para o 
elemento que foi "iterado" anteriormente.
[/box]

[box Usar Iterator em Java 5 em vez do enhanced-for?]
O %%Iterator%% pode sim ainda ser útil no Java 5. Além de iterar na coleção como faz o enhanced-for,
o %%Iterator%% consegue remover elementos da coleção durante a iteração.
[/box]

[section Mapas - java.util.Map]
Muitas vezes queremos buscar rapidamente um objeto dado alguma informação sobre ele. Um exemplo
seria, dada a placa do carro, obter todos os dados do carro. Poderíamos utilizar uma lista para
isso e percorrer todos os seus elementos, mas isso pode ser péssimo para a performance, mesmo
para listas não muito grandes. Aqui entra o mapa.

Um mapa é composto por um conjunto de associações entre um objeto chave a um objeto valor.
É equivalente ao conceito de dicionário, usado em várias linguagens. Algumas linguagens, como
Perl ou PHP, possuem um suporte mais direto a mapas, onde são conhecidos como matrizes/arrays 
associativas.

[note]
Use na lousa o exemplo em uma pseudo linguagem:

cpfs["maria"] = 28848546811
cpfs["joaquim"] = 66666666666
cpfs["manoel"] = 333333331

Separe bem os lados Chave e o lado Valor. Outro exemplo bom é o %%.ini%% do visual basic e o
regedit do windows.
[/note]

%%java.util.Map%% é um mapa, pois é possível usá-lo para mapear uma chave a um valor, por exemplo:
mapeie à chave "empresa" o valor "Caelum", ou então mapeie à chave "rua" ao valor "Vergueiro". 
Semelhante a associações de palavras que podemos fazer em um dicionário.

[img images/collections/mapa.png w=70%]

O método %%put(Object, Object)%% da interface %%Map%% recebe a chave e o valor de uma nova 
associação. Para saber o que está associado a um determinado objeto-chave, passa-se esse objeto no 
método %%get(Object)%%. Sem dúvida essas são as duas operações principais e mais frequentes realizadas
sobre um mapa.

Observe o exemplo: criamos duas contas correntes e as colocamos em um mapa associando-as aos seus donos.

[code java]
    ContaCorrente c1 = new ContaCorrente();
    c1.deposita(10000);
  
    ContaCorrente c2 = new ContaCorrente();
    c2.deposita(3000);
  
    // cria o mapa
    Map<String, ContaCorrente> mapaDeContas = new HashMap<String, ContaCorrente>();
  
    // adiciona duas chaves e seus respectivos valores
    mapaDeContas.put("diretor", c1);
    mapaDeContas.put("gerente", c2);

    // qual a conta do diretor? (sem casting!)
    ContaCorrente contaDoDiretor = mapaDeContas.get("diretor");
    System.out.println(contaDoDiretor.getSaldo());
[/code]

Um mapa é muito usado para "indexar" objetos de acordo com determinado critério,
para podermos buscar esse objetos rapidamente. Um mapa costuma aparecer
juntamente com outras coleções, para poder realizar essas buscas!

Ele, assim como as coleções, trabalha diretamente com %%Objects%% (tanto na chave quanto no 
valor), o que tornaria necessário o casting no momento que recuperar elementos. Usando
os generics, como fizemos aqui, não precisamos mais do casting. 

[index HASHMAP]
[index TREEMAP]
[index HASHTABLE]
Suas principais implementações são o %%HashMap%%, o %%TreeMap%% e o %%Hashtable%%.

Apesar do mapa fazer parte do framework, ele não estende a interface %%Collection%%, por ter um 
comportamento bem diferente. Porém, as coleções internas de um mapa (a de chaves e a de valores, ver 
Figura 7) são acessíveis por métodos definidos na interface %%Map%%.

[img images/collections/map.png w=35%]

O método %%keySet()%% retorna um %%Set%% com as chaves daquele mapa e o método %%values()%% retorna 
a %%Collection%% com todos os valores que foram associados a alguma das chaves. 

[section Para saber mais: Properties]

[note]
	Se for comentar na aula, compensa mostrar o mau uso de herança nesse caso. Properties herda
	de Hashtable e é um Map. Nojento porque tem um metodo put(Object,Object) que nao deve ser chamado
	se nao for String.
	
	Do javadoc: "Because Properties inherits from Hashtable, the put and putAll methods can be applied to
	a Properties object. Their use is strongly discouraged as they allow the caller to insert entries 
	whose keys or values are not Strings. The setProperty method should be used instead."
[/note]
Um mapa importante é a tradicional classe %%Properties%%, que mapeia strings e é muito utilizada para 
a configuração de aplicações. 

A %%Properties%% possui, também, métodos para ler e gravar o mapeamento com base em um arquivo texto, 
facilitando muito a sua persistência.

[code java]
	Properties config = new Properties();
	  
	config.setProperty("database.login", "scott");
	config.setProperty("database.password", "tiger");
	config.setProperty("database.url","jdbc:mysql:/localhost/teste");

	// muitas linhas depois...

	String login = config.getProperty("database.login");
	String password = config.getProperty("database.password");
	String url = config.getProperty("database.url");
	DriverManager.getConnection(url, login, password);
[/code]

Repare que não houve a necessidade do casting para %%String%% no momento de recuperar os objetos 
associados. Isto porque a classe %%Properties%% foi desenhada com o propósito de trabalhar com a 
associação entre %%Strings%%.

[section Para saber mais: Equals e HashCode]
Muitas das coleções do java guardam os objetos dentro de tabelas de hash. Essas tabelas são 
utilizadas para que a pesquisa de um objeto seja feita de maneira rápida.
	
Como funciona? Cada objeto é "classificado" pelo seu %%hashCode%% e, com isso, conseguimos espalhar 
cada objeto agrupando-os pelo %%hashCode%%. Quando buscamos determinado objeto, só vamos procurar 
entre os elementos que estão no grupo daquele %%hashCode%%. Dentro desse grupo, vamos testando o 
objeto procurado com o candidato usando %%equals()%%.
	
Para que isso funcione direito, o método %%hashCode%% de cada objeto deve retornar o mesmo valor para 
dois objetos, se eles são considerados %%equals%%. Em outras palavras:
	
%%a.equals(b)%% implica %%a.hashCode() == b.hashCode()%%
	
Implementar %%hashCode%% de tal maneira que ele retorne valores diferentes para dois objetos 
considerados %%equals%% quebra o contrato de %%Object%% e resultará em collections que usam 
espalhamento (como %%HashSet%%, %%HashMap%% e %%Hashtable%%), não achando objetos iguais dentro de 
uma mesma coleção.

[box No Eclipse...]
O Eclipse é capaz de gerar uma implementação correta de equals e hashcode baseado nos atributos
que você queira comparar. Basta ir no menu Source e depois em Generate hashcode() and equals().
[/box]

[section Para saber mais: Boas práticas] 
As coleções do Java oferecem grande flexibilidade ao usuário. A perda de performance em relação à 
utilização de arrays é irrelevante, mas deve-se tomar algumas precauções:
	
[list]
	* Grande parte das coleções usam, internamente, um array para armazenar os seus dados. Quando 
esse array não é mais suficiente, é criada um maior e o conteúdo da antiga é copiado. Este processo 
pode acontecer muitas vezes, no caso de você ter uma coleção que cresce muito. Você deve, então, 
criar uma coleção já com uma capacidade grande, para evitar o excesso de redimensionamento.

	* Evite usar coleções que guardam os elementos pela sua ordem de comparação quando não há 
necessidade. Um %%TreeSet%% gasta computacionalmente %%**O(log(n))**%% para inserir (ele utiliza uma 
árvore rubro-negra como implementação), enquanto o %%HashSet%% gasta apenas %%**O(1)**%%.

	* Não itere sobre uma %%List%% utilizando um %%for%% de %%0%% até %%list.size()%% e usando 
%%get(int)%% para receber os objetos. Enquanto isso parece atraente, algumas implementações da 
%%List%% não são de acesso aleatório como a %%LinkedList%%, fazendo esse código ter uma péssima 
performance computacional. (use %%Iterator%%)
[/list]

[section Exercícios: Collections]

[note]
	Não deixe de fazer a pergunta conceitual do exercicio 2 junto com os alunos tambem!
	Eles vao poder exercitar o polimorfismo. Voce pode tambem perguntar se valeria
	a pena referenciar a ArrayList como sendo um Object, e fazer eles perceberem
	que é legal sempre se referenciar o mais generico possivel, mas nem sempre
	faz sentido:
	
	Object x = new ArrayList();
[/note]

[exercise]
	[question]
		Crie um código que insira 30 mil números numa %%ArrayList%% e pesquise-os. Vamos usar um 
		método de %%System%% para cronometrar o tempo gasto:
		
		[code java]
			public class TestaPerformance {
			
				public static void main(String[] args) {
					System.out.println("Iniciando...");
					long inicio = System.currentTimeMillis();
					Collection<Integer> teste = new ArrayList<Integer>();
					
					int total = 30000;
					
					for (int i = 0; i < total; i++) {
						teste.add(i);
					}
					
					for (int i = 0; i < total; i++) {
						teste.contains(i);
					}
					
					long fim = System.currentTimeMillis();
					long tempo = fim - inicio;
					System.out.println("Tempo gasto: " + tempo);
				}
			}
		[/code]
		
		Troque a %%ArrayList%% por um %%HashSet%% e verifique o tempo que vai demorar:
		[code java]
			Collection<Integer> teste = new HashSet<Integer>();
		[/code]
		
		O que é lento? A inserção de 30 mil elementos ou as 30 mil buscas? Descubra computando
		o tempo gasto em cada %%for%% separadamente.
		
		A diferença é mais que gritante. Se você passar de 30 mil para um número maior, como 50 ou 
		100 mil, verá que isso inviabiliza por completo o uso de uma %%List%%, no caso em que 
		queremos utilizá-la essencialmente em pesquisas.
	[/question]
	[question]
		(conceitual, importante) Repare que, se você declarar a coleção e der %%new%% assim:
		
		[code java]
			Collection<Integer> teste = new ArrayList<Integer>();
		[/code]
		
		em vez de
		
		[code java]
			ArrayList<Integer> teste = new ArrayList<Integer>();
		[/code]
		
		É garantido que vai ter de alterar só essa linha para substituir a implementação por 
		%%HashSet%%. Estamos aqui usando o polimorfismo para nos proteger que mudanças de 
		implementação venham nos obrigar a alterar muito código. Mais uma vez: ::programe voltado a 
		interface, e não à implementação::! Esse é um **excelente** exemplo de bom uso de interfaces, 
		afinal, de que importa como a coleção funciona? O que queremos é uma coleção qualquer, 
		isso é suficiente para os nossos propósitos! Nosso código está com **baixo acoplamento**
		em relação a estrutura de dados utilizada: podemos trocá-la facilmente.
		
		Esse é um código extremamente elegante e flexível. Com o tempo você vai reparar que
		as pessoas tentam programar sempre se referindo a essas interfaces menos específicas,
		na medida do possível:
		os métodos costumam receber e devolver %%Collection%%s, %%List%%s e %%Set%%s
		em vez de referenciar diretamente uma implementação. É o mesmo que ocorre
		com o uso de %%InputStream%% e %%OutputStream%%: eles são o suficiente, não
		há porque forçar o uso de algo mais específico.		
		
		Obviamente, algumas vezes não conseguimos 
		trabalhar dessa forma e precisamos usar uma interface mais específica ou mesmo nos referir ao 
		objeto pela sua implementação para poder chamar alguns métodos. Por exemplo, 
		%%TreeSet%% tem mais métodos que os definidos em %%Set%%, assim como %%LinkedList%% em relação a 
		%%List%%.		
	[/question]	
	[question]
		Faça testes com o %%Map%%, como visto nesse capítulo:
		
		[code java]
			public class TestaMapa {
				
				public static void main(String[] args) {
					Conta c1 = new ContaCorrente();
					c1.deposita(10000);
			
					Conta c2 = new ContaCorrente();
					c2.deposita(3000);
			
					// cria o mapa
					Map mapaDeContas = new HashMap();
			
					// adiciona duas chaves e seus valores
					mapaDeContas.put("diretor", c1);
					mapaDeContas.put("gerente", c2);
			
					// qual a conta do diretor?
					Conta contaDoDiretor = (Conta) mapaDeContas.get("diretor");
					System.out.println(contaDoDiretor.getSaldo());
				}
			}
		[/code]

	Depois, altere o código para usar o generics, e não haver a necessidade do casting,
	além da garantia de que nosso mapa estará seguro em relação a tipagem usada.
	
	Você pode utilizar o quickfix do Eclipse para ele consertar isso,
	na linha em que você está chamando o %%put%%. Depois de mais
	um quickfix (descubra!) seu código deve ficar como segue:
	
[code java]
	// cria o mapa
	Map<String, Conta> mapaDeContas = new HashMap<String, Conta>();
[/code]				

	[/question]
	
	[question]
		(opcional) Assim como no exercício 1, crie uma comparação entre %%ArrayList%% e 
		%%LinkedList%%, para ver qual é a mais rápida para se adicionar elementos na primeira posição 
		(%%list.add(0, elemento)%%), como por exemplo:		
		
		[code java]
			public class TestaPerformance2 {
				public static void main(String[] args) {
					System.out.println("Iniciando...");
					long inicio = System.currentTimeMillis();
	
					// trocar depois por ArrayList				
					List<Integer> teste = new LinkedList<Integer>();
					
					for (int i = 0; i < 30000; i++) {
						teste.add(0, i);
					}

					long fim = System.currentTimeMillis();
					double tempo = (fim - inicio) / 1000.0;
					System.out.println("Tempo gasto: " + tempo);
				}
			}
		[/code]
		
		Seguindo o mesmo raciocínio, você pode ver qual é a mais rápida para se percorrer usando o %%get(indice)%% 
		(sabemos que o correto seria utilizar o enhanced for ou o iterator). Para isso,
		insira 30 mil elementos e depois percorra-os usando cada implementação de %%List%%.
		
		Perceba que aqui o nosso intuito não é que você aprenda quem é mais rápido que quem,
		o importante é perceber que podemos tirar proveito do polimorfismo para nos
		comprometer apenas com a interface. Depois, quando necessário, podemos
		trocar e escolher uma implementação mais adequada as nossas necessidades.
		Mais uma vez aqui vemos a vantagem de programar voltado a interface.
	[/question]
	
	[question]
		(opcional) Crie uma classe %%Banco%% que possui uma %%List%% de %%Conta%% chamada
		%%contas%%. Repare que numa lista de 
		%%Conta%%, você pode colocar tanto %%ContaCorrente%% quanto %%ContaPoupanca%%
		por causa do polimorfismo. 
		
		Crie um método 
		%%void adiciona(Conta c)%%, um método %%Conta pega(int x)%% e outro 
		%%int pegaTotalDeContas()%%, muito similar à relação anterior de Empresa-Funcionário.
		Basta usar a sua lista e delegar essas chamadas para os métodos e coleções
		que estudamos.
	[/question]
	
	[question]
		(opcional) No %%Banco%%, crie um método %%Conta buscaPorNome(String nome)%%
		que procura por uma %%Conta%% cujo %%nome%% seja %%equals%% ao %%nome%% dado.
		
		Você pode implementar esse método com um %%for%% na sua lista de %%Conta%%,
		porém não tem uma performance eficiente.
		
		Adicionando um atributo privado do tipo %%Map<String, Conta>%% terá um
		impacto significativo. Toda vez que o método %%adiciona(Conta c)%% for
		invocado, você deve invocar %%.put(c.getNome(), c)%% no seu mapa.
		Dessa maneira, quando alguém invocar o método %%Conta buscaPorNome(String nome)%%,
		basta você fazer o %%get%% no seu mapa, passando %%nome%% como argumento!
		
		Acontece às vezes de termos mais de um mapa, se precisarmos buscar
		por objetos por mais de um critério.
	[/question]
	
	[question]
		(opcional, avançado) Crie o método %%hashCode%% para a sua conta, de forma que ele respeite 
		o %%equals%% de que duas contas são %%equals%% quando tem o mesmo número. Verifique se sua 
		classe funciona corretamente num %%HashSet%%. Remova o método %%hashCode%%. Continua 
		funcionando?
	
		Dominar o uso e o funcionamento do %%hashCode%% é fundamental para o bom programador.
	[/question]
[/exercise]	

[section Desafios]
[exercise]
	[question]
		Gere todos os números entre 1 e 1000 e ordene em ordem decrescente utilizando um %%TreeSet%%.
	[/question]
	[question]
		Gere todos os números entre 1 e 1000 e ordene em ordem decrescente utilizando um 
		%%ArrayList%%.
	[/question]
[/exercise]
