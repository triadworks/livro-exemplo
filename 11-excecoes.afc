[chapter Controlando os erros com Exceções]

[quote "Quem pensa pouco, erra muito"--Leonardo da Vinci]

Ao término desse capítulo, você será capaz de:
[list]
* controlar erros e tomar decisões baseadas nos mesmos;
* criar novos tipos de erros para melhorar o tratamento deles em sua aplicação ou biblioteca;
* assegurar que um método funcionou como diz em seu "contrato".
[/list]

[section Motivação]
[note]
* O que significa código de erro -4? E 5? E true/false? Meu problemas têm nomes?
* Onde que aconteceu o problema?
* Por onde eu havia passado até acontecer o problema?
* E se eu esquecer de olhar o retorno do método saca? Alguém me obriga a fazer isso?
[/note]

Voltando às %%Conta%%s que criamos no capítulo 6, o que aconteceria ao tentar chamar o método 
%%saca%% com um valor fora do limite? O sistema mostraria uma mensagem de erro, mas quem chamou o 
método %%saca%% não saberá que isso aconteceu.

Como avisar aquele que chamou o método de que ele não conseguiu fazer aquilo que deveria?

Em Java, os métodos dizem qual o **contrato** que eles devem seguir. Se, ao tentar sacar, ele não 
consegue fazer o que deveria, ele precisa, ao menos, avisar ao usuário que o saque não foi feito.

Veja no exemplo abaixo: estamos forçando uma %%Conta%% a ter um valor negativo, isto é, estar num 
estado inconsistente de acordo com a nossa modelagem.

[code java]
Conta minhaConta = new Conta();
minhaConta.deposita(100);
minhaConta.setLimite(100);
minhaConta.saca(1000);
//	 o saldo é -900? É 100? É 0? A chamada ao método saca funcionou?
[/code]

Em sistemas de verdade, é muito comum que quem saiba tratar o erro é aquele que chamou o método e não 
a própria classe! Portanto, nada mais natural do que a classe sinalizar que um erro ocorreu.

A solução mais simples utilizada antigamente é a de marcar o retorno de um método como %%boolean%% e 
retornar %%true%%, se tudo ocorreu da maneira planejada, ou %%false%%, caso contrário:

[code java]
boolean saca(double quantidade) {
  if (quantidade > this.saldo + this.limite) { //posso sacar até saldo+limite
		System.out.println("Não posso sacar fora do limite!");
		return false;
	} else {
		this.saldo = this.saldo - quantidade;
		return true;
	}
}
[/code]

Um novo exemplo de chamada ao método acima:

[code java]
Conta minhaConta = new Conta();
minhaConta.deposita(100);
minhaConta.setLimite(100);
if (!minhaConta.saca(1000)) {
	System.out.println("Não saquei");
}
[/code]

Repare que tivemos de lembrar de testar o retorno do método, mas não somos obrigados a 
fazer isso. Esquecer de testar o retorno desse método teria consequências drásticas: a 
máquina de autoatendimento  poderia vir a liberar a quantia desejada de dinheiro, mesmo 
que o sistema não tivesse conseguido efetuar o método %%saca%% com sucesso, como no 
exemplo a seguir:

	[code java]
		Conta minhaConta = new Conta();
		minhaConta.deposita(100);
		
		// ...
		double valor = 5000;
		minhaConta.saca(valor); // vai retornar false, mas ninguem verifica!
		caixaEletronico.emite(valor);
	[/code]


Mesmo invocando o método e tratando o retorno de maneira correta, o que faríamos se fosse 
necessário sinalizar quando o usuário passou um valor negativo como **quantidade**? 
Uma solução seria alterar o retorno de %%boolean%% para %%int%% e retornar o código do erro que ocorreu. 
Isso é considerado uma má prática (conhecida também como uso de "::magic numbers::").

Além de você perder o retorno do método, o valor devolvido é "mágico" e só legível perante extensa 
documentação, além de não obrigar o programador a tratar esse retorno e, no caso de esquecer isso, 
seu programa continuará rodando já num estado inconsistente.

Repare o que aconteceria se fosse necessário retornar um outro valor. O exemplo abaixo mostra um caso 
onde, através do retorno, não será possível descobrir se ocorreu um erro ou não, pois o método 
retorna um cliente.

[code java]
public Cliente procuraCliente(int id) {
	if (idInvalido) {
		// avisa o método que chamou este que ocorreu um erro
	} else {
		Cliente cliente = new Cliente();
		cliente.setId(id);
		// cliente.setNome("nome do cliente");
		return cliente;
	}
}
[/code]

Por esses e outros motivos, utilizamos um código diferente em Java para tratar aquilo que chamamos de 
exceções: os casos onde acontece algo que, normalmente, não iria acontecer. O exemplo do argumento do 
saque inválido ou do %%id%% inválido de um cliente é uma **exceção** à regra.

[box Exceção]
Uma exceção representa uma situação que normalmente não ocorre e representa algo de estranho ou 
inesperado no sistema.
[/box]

[section Exercício para começar com os conceitos]

Antes de resolvermos o nosso problema, vamos ver como a Java Virtual Machine age
ao se deparar com situações inesperadas, como divisão por zero ou acesso a um índice
da array que não existe.

[note]
Antes deles fazerem esse exercicio, voce precisa escreve-lo na lousa (nao precisa
por system.out na lousa) e simular
a pilha!! Para fazer eles  perceberem que aquilo eh o stacktrace. Mesmo para o exercicio 2!
 Mostre o try catch na lousa antes..

Enfatizar o fato de nossas exceções de execução possuem nome e um rastro (o que estava na pilha). 
Tomar cuidado para NÃO utilizar o nome ERRO.

Deixar bem claro que esse exercicio é para praticar um pouco o conceito e sinaxe
basica, porque ele em si nao tem pe nem cabeça.

Use os termos "java LANÇA uma bomba" e verifica se "alguem esta se
preocupando com esse tipo de bomba para PEGA-LA", se nao estiver "a bomba continua
a cair na pilha", ate chegar no main, onde para.

Use os verbos LANCAR e PEGAR por causa do throw e catch. 

Cuidado com associacao do bloco try a uma transacao: nao ha rollback,
pode confundir... mas é uma boa analogia.
[/note]

[exercise]
[question]
Para aprendermos os conceitos básicos das exceptions do Java,
teste o seguinte código você mesmo:

[code java]
class TesteErro {
	public static void main(String[] args) {
		System.out.println("inicio do main");
		metodo1();
		System.out.println("fim do main");
	}
	
	static void metodo1() {
		System.out.println("inicio do metodo1");
		metodo2();
		System.out.println("fim do metodo1");
	}
	
	static void metodo2() {
		System.out.println("inicio do metodo2");
		int[] array = new int[10];
		for (int i = 0; i <= 15; i++) {
			array[i] = i;			
			System.out.println(i);
		}
		System.out.println("fim do metodo2");
	}
}
[/code]

Repare o método %%main%% chamando %%metodo1%% e esse, por sua vez, chamando o %%metodo2%%. Cada um 
desses métodos pode ter suas próprias variáveis locais, sendo que, por exemplo, o %%metodo1%% não 
enxerga as variáveis declaradas dentro do %%main%%.

Como o Java (e muitas das outras linguagens) faz isso? Toda invocação de método é empilhada... em uma 
estrutura de dados que isola a área de memória de cada um. Quando um método termina (retorna), ele 
volta para o método que o invocou. Ele descobre isso através da **pilha de execução** (::stack::).
Basta jogar fora um gomo da pilha (::stackframe::):

[img images/excecoes/pilha_execucao.png w=25]

Porém, o nosso %%metodo2%% propositadamente possui um enorme problema: está acessando um índice de 
array indevido para esse caso; o índice estará fora dos limites da array quando chegar em %%10%%!

[index EXCEPTION]
Rode o código. Qual é a saída? O que isso representa? O que ela indica?

[img images/excecoes/array_out_bounds1.png w=80]

[index STACKTRACE]
Essa é o  conhecido **rastro da pilha** (::stacktrace::). É uma saída importantíssima para o 
programador - tanto que, em qualquer fórum ou lista de discussão, é comum os programadores enviarem, 
juntamente com a descrição do problema, essa stacktrace.

Por que isso aconteceu? O sistema de exceções do Java funciona da seguinte maneira: quando uma 
exceção é **lançada** (::throws::), a JVM entra em estado de alerta e vai ver se o método atual toma 
alguma precaução ao **tentar** executar esse trecho de código. Como podemos ver, o %%metodo2%% não 
toma nenhuma medida diferente do que vimos até agora.

Como o %%metodo2%% não está **tratando** esse problema, a JVM pára a execução dele anormalmente, sem 
esperar ele terminar, e volta um ::stackframe:: pra baixo, onde será feita nova verificação: o 
%%metodo1%% está se precavendo de um problema chamado %%ArrayIndexOutOfBoundsException%%? Não... 
volta para o %%main%%, onde também não há proteção, então a JVM morre (na verdade, quem morre é apenas 
a %%Thread%% corrente, veremos mais para frente).

Obviamente, aqui estamos forçando esse caso, e não faria sentido tomarmos cuidado com ele. É fácil 
arrumar um problema desses: basta percorrermos a array no máximo até o seu %%length%%.

Porém, apenas para entender o controle de fluxo de uma %%Exception%%, vamos colocar o código que vai 
**tentar** (::try::) executar o bloco perigoso e, caso o problema seja do tipo 
%%ArrayIndexOutOfBoundsException%%, ele será **pego** (::catched::). Repare que é interessante que 
cada exceção no Java tenha um tipo... ela pode ter atributos e métodos.
[/question]

[question]
Adicione um %%try/catch%% em volta do %%for%%, pegando %%ArrayIndexOutOfBoundsException%%. O que o 
código imprime?

[code java]
try {
	for (int i = 0; i <= 15; i++) {
		array[i] = i;			
		System.out.println(i);
	}
} catch (ArrayIndexOutOfBoundsException e) {
	System.out.println("erro: " + e);
}
[/code]

[img images/excecoes/array_out_bounds2.png w=80]

Em vez de fazer o %%try%% em torno do %%for%% inteiro, tente apenas com o bloco de dentro do %%for%%:

[code java]
for (int i = 0; i <= 15; i++) {
	try {
		array[i] = i;			
		System.out.println(i);
	} catch (ArrayIndexOutOfBoundsException e) {
		System.out.println("erro: " + e);
	}
}
[/code]

Qual é a diferença?

[img images/excecoes/array_out_bounds3.png w=80]

Retire o %%try/catch%% e coloque ele em volta da chamada do %%metodo2%%.

[code java]
System.out.println("inicio do metodo1");
try {
	metodo2();
} catch (ArrayIndexOutOfBoundsException e) {
	System.out.println("erro: " + e);
}
System.out.println("fim do metodo1");
[/code]

[img images/excecoes/array_out_bounds4.png w=80]

Faça o mesmo, retirando o %%try/catch%% novamente e colocando em volta da chamada do 
%%metodo1%%. Rode os códigos, o que acontece?

[code java]
System.out.println("inicio do main");
try {
	metodo1();
} catch (ArrayIndexOutOfBoundsException e) {
	System.out.println("Erro : "+e);
}
System.out.println("fim do main");
[/code]

[img images/excecoes/array_out_bounds5.png w=80]

Repare que, a partir do momento que uma exception foi ::catched:: (pega, tratada, handled), a execução volta 
ao normal a partir daquele ponto.
[/question]
[/exercise]

[section Exceções de Runtime mais comuns]

Que tal tentar dividir um número por zero? Será que a JVM consegue fazer aquilo que nós 
definimos que não existe?

[code java]
public class TestandoADivisao {
	
	public static void main(String args[]) {
		int i = 5571;
		i = i / 0;
		System.out.println("O resultado  " + i);
	}
}
[/code]

Tente executar o programa acima. O que acontece?

[img images/excecoes/divisao_por_zero.png w=80]

[code java]
public class TestandoReferenciaNula {
	public static void main(String args[]) {
		Conta c = null;
		System.out.println("Saldo atual " + c.getSaldo());
	}
}
[/code]

Tente executar este programa. O que acontece?

[img images/excecoes/null_pointer_exception.png w=85]

Repare que um %%ArrayIndexOutOfBoundsException%% ou um %%NullPointerException%% poderia ser 
facilmente evitado com o %%for%% corretamente escrito ou com %%if%%s que checariam os limites da 
array.

Outro caso em que também ocorre tal tipo de exceção é quando um cast errado é feito (veremos mais 
pra frente). Em todos os casos, tais problemas provavelmente poderiam ser evitados pelo programador. É 
por esse motivo que o java não te obriga a dar o try/catch nessas exceptions e chamamos essas 
exceções de ::unchecked::. Em outras palavras, o compilador não checa se você está tratando essas 
exceções.

[box Erros]
Os erros em Java são um tipo de exceção que também podem ser tratados. Eles representam problemas na 
máquina virtual e não devem ser tratados em 99% dos casos, já que provavelmente o melhor a se fazer 
é deixar a JVM encerrar (ou apenas a Thread em questão).
[/box]

[section Outro tipo de exceção: Checked Exceptions]

[note]
Aqui voce deve usar a mesma lousa que a anterior, e fazer com que
o main, chama o metodo1 que chama o metodo2, que da new em FileInputStream.
[/note]

Fica claro, com os exemplos de código acima, que não é necessário declarar que você está tentando 
fazer algo onde um erro possa ocorrer. Os dois exemplos, com ou sem o %%try/catch%%, compilaram e 
rodaram. Em um, o erro terminou o programa e, no outro, foi possível tratá-lo.

Mas não é só esse tipo de exceção que existe em Java. Um outro tipo, obriga a quem chama
o método ou construtor a tratar essa exceção. Chamamos esse tipo de exceção de ::checked::,
pois o compilador checará se ela está sendo devidamente tratada, diferente das anteriores,
conhecidas como ::unchecked::.

Um exemplo interessante é o de abrir um arquivo para leitura, onde pode ocorrer o erro do arquivo 
não existir (veremos como trabalhar com arquivos em outro capítulo, **não** se preocupe com isto agora):

[code java]
class Teste {
	public static void metodo() {
		new java.io.FileInputStream("arquivo.txt");
	}
}
[/code]

O código acima não compila e o compilador avisa que é necessário tratar o %%FileNotFoundException%% 
que pode ocorrer:

[TODO trocar por FileInputStream em vez de FileReader]
[img images/excecoes/checked_exception.png w=80]

Para compilar e fazer o programa funcionar, temos duas maneiras que podemos tratar o problema. O 
primeiro, é tratá-lo com o %%try%% e %%catch%% do mesmo jeito que usamos no exemplo anterior, com 
uma array:

[code java]
public static void metodo() {
	
	try {
		new java.io.FileInputStream("arquivo.txt");
	} catch (java.io.FileNotFoundException e) {
		System.out.println("Nao foi possivel abrir o arquivo para leitura");
	}
	
}
[/code]

[index THROWS]
A segunda forma de tratar esse erro, é delegar ele para quem chamou o nosso método, isto é, passar 
para a frente.

[code java]
public static void metodo() throws java.io.FileNotFoundException {
	
	new java.io.FileInputStream("arquivo.txt");

}
[/code]

No Eclipse é bem simples fazer tanto um %%try/catch%% como um %%throws%%:

Tente digitar esse código no eclipse:

[code java]
public class TestaException {
	public static void main(String[] args) {
		new java.io.FileInputStream("arquivo.txt");
	}
}
[/code]

O Eclipse vai reclamar :

[TODO trocar por FileInputStream em vez de FileReader]
[img images/excecoes/throws_try_catch.png w=50]

E você tem duas opções:

[list number]
* ::Add throws declaration::, que vai gerar:
[code java]
	public class TestaException {
		public static void main(String[] args) throws FileNotFoundException {
			new java.io.FileInputStream("arquivo.txt");
		}
	}
[/code]

* ::Surround with try/catch::, que vai gerar:
[code java]
	public class TestaException2 {
		public static void main(String[] args) {
			try {
				new java.io.FileInputStream("arquivo.txt");
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
[/code]

[/list]

No início, existe uma grande tentação de sempre passar o problema pra frente para outros o tratarem. 
Pode ser que faça sentido, dependendo do caso, mas não até o main, por exemplo. Acontece que quem 
tenta abrir um arquivo sabe como lidar com um problema na leitura. Quem chamou um método no começo 
do programa pode não saber ou, pior ainda, tentar abrir cinco arquivos diferentes e não saber qual 
deles teve um problema! 

Não há uma regra para decidir em que momento do seu programa você vai tratar determinada exceção. 
Isso vai depender de em que ponto você tem condições de tomar uma decisão em relação àquele erro. 
Enquanto não for o momento, você provavelmente vai preferir delegar a responsabilidade para o método 
que te invocou.

Um outro problema comum é quando trabalhamos com banco de dados: 
[box Boas práticas no tratamento de exceções]
No blog da Caelum há um extenso artigo discutindo as boas práticas em relação ao tratamento de exceções.

http://blog.caelum.com.br/2006/10/07/lidando-com-exceptions/
[/box]

[section Um pouco da grande famíla Throwable]

Uma pequena parte da  Família Throwable:

[img images/excecoes/arvore_heranca_throwable.png w=75]

[section Mais de um erro]

É possível tratar mais de um erro quase que ao mesmo tempo:
[list number]
* Com o try e catch:
[code java]
try {
	objeto.metodoQuePodeLancarIOeSQLException();
} catch (IOException e) {
	// ..
} catch (SQLException e) {
	// ..
}
[/code]

* Com o %%throws%%:
[code java]
public void abre(String arquivo) throws IOException, SQLException {
	// ..
}
[/code]

* Você pode, também, escolher tratar algumas exceções e declarar as outras no throws:
[code java]
public void abre(String arquivo) throws IOException {
	try {
		objeto.metodoQuePodeLancarIOeSQLException();
	} catch (SQLException e) {
		// ..
	}
}
[/code]
[/list]

É desnecessário declarar no %%throws%% as exceptions que são ::unchecked::, porém é permitido e às 
vezes, facilita a leitura e a documentação do seu código.

[section Lançando exceções]
Lembre-se do método %%saca%% da nossa classe %%Conta%%. Ele devolve um %%boolean%% caso consiga ou 
não sacar:

[code java]
boolean saca(double valor) {
	if (this.saldo < valor) {
		return false;
	} else {
		this.saldo-=valor;
		return true;
	}		
}
[/code]

Podemos, também, lançar uma %%Exception%%, o que é extremamente útil. Dessa maneira, resolvemos o 
problema de alguém poder esquecer de fazer um %%if%% no retorno de um método.

A palavra chave **throw**, que está no imperativo, lança uma %%Exception%%. 
Isto é bem diferente de %%throws%%, que está no presente do indicativo, e que apenas avisa da 
possibilidade daquele método lançá-la, obrigando o outro método que vá utilizar deste
de se preocupar com essa exceção em questão. 

[code java]
void saca(double valor) {
	if (this.saldo < valor) {
		throw new RuntimeException();
	} else {
		this.saldo-=valor;		
	}		
}
[/code]

No nosso caso, lança uma do tipo ::unchecked::. %%RuntimeException%% é a exception mãe de todas as 
exceptions ::unchecked::. A desvantagem, aqui, é que ela é muito genérica; quem receber esse erro não 
sabe dizer exatamente qual foi o problema. Podemos então usar uma Exception mais específica: 

[code java]
void saca(double valor) {
	if (this.saldo < valor) {
		throw new IllegalArgumentException();
	} else {
		this.saldo-=valor;		
	}		
}
[/code]

%%IllegalArgumentException%% diz um pouco mais: algo foi passado como argumento e seu método não 
gostou. Ela é uma Exception ::unchecked:: pois estende de %%RuntimeException%% e já faz parte da 
biblioteca do java. (%%IllegalArgumentException%% é a melhor escolha quando um argumento sempre é 
inválido como, por exemplo, números negativos, referências nulas, etc).

Para pegar esse erro, não usaremos um %%if/else%% e sim um %%try/catch%%, porque faz mais 
sentido já que a falta de saldo é uma exceção:

[code java]
Conta cc = new ContaCorrente();
cc.deposita(100);

try {
	cc.saca(100);
} catch (IllegalArgumentException e) {
	System.out.println("Saldo Insuficiente");
}
[/code]

Podíamos melhorar ainda mais e passar para o construtor da %%IllegalArgumentException%% o motivo da 
exceção:

[code java]
void saca(double valor) {
	if (this.saldo < valor) {
		throw new IllegalArgumentException("Saldo insuficiente");
	} else {
		this.saldo-=valor;		
	}		
}
[/code]

O método %%getMessage()%% definido na classe %%Throwable%% (mãe de todos os tipos de erros e 
exceptions) vai retornar a mensagem que passamos ao construtor da %%IllegalArgumentException%%.

[code java]
try {
	cc.saca(100);
} catch (IllegalArgumentException e) {
	System.out.println(e.getMessage());
}
[/code]

[section O que colocar dentro do try?]

Imagine que vamos sacar dinheiro de diversas contas:

[code java]
Conta cc = new ContaCorrente();
cc.deposita(100);

Conta cp = new ContaPoupanca();
cp.deposita(100);

// sacando das contas:

cc.saca(50);
System.out.println("consegui sacar da corrente!");

cp.saca(50);
System.out.println("consegui sacar da poupanca!");
[/code]

Podemos escolher vários lugares para colocar try/catch:

[code java]
try {
	cc.saca(50);	
} catch (IllegalArgumentException e) {
	System.out.println(e.getMessage());
}
System.out.println("consegui sacar da corrente!");

try {
	cp.saca(50);
} catch (IllegalArgumentException e) {
	System.out.println(e.getMessage());
}
System.out.println("consegui sacar da poupanca!");
[/code]

Essa não parece uma opção boa, pois a mensagem ::"consegui sacar"::
será impressa mesmo que o %%catch%% seja acionado. Sempre que temos
algo que depende da linha de cima para ser correto, devemos
agrupá-lo no %%try%%:

[code java]
try {
	cc.saca(50);	
	System.out.println("consegui sacar da corrente!");
} catch (IllegalArgumentException e) {
	System.out.println(e.getMessage());
}

try {
	cp.saca(50);
	System.out.println("consegui sacar da poupanca!");
} catch (IllegalArgumentException e) {
	System.out.println(e.getMessage());
}
[/code]

Mas há ainda uma outra opção: imagine que, para o nosso sistema,
uma falha ao sacar da conta poupança deve parar o processo
de saques e nem tentar sacar da conta corrente. Para isso, agruparíamos
mais ainda:

[code java]
try {
	cc.saca(50);	
	System.out.println("consegui sacar da corrente!");
	cp.saca(50);
	System.out.println("consegui sacar da poupanca!");
} catch (IllegalArgumentException e) {
	System.out.println(e.getMessage());
}
[/code]

**O que você vai colocar dentro do %%try%% influencia muito
a execução do programa!** Pense direito nas linhas que dependem
uma da outra para a execução correta da sua lógica de negócios.


[section Criando seu próprio tipo de exceção]

É bem comum criar uma própria classe de exceção para controlar melhor o uso de suas exceções. Dessa 
maneira, podemos passar valores específicos para ela carregar, que sejam úteis de alguma forma. 
Vamos criar a nossa:

Voltamos para o exemplo das %%Contas%%, vamos criar a nossa Exceção de %%SaldoInsuficienteException%%:

[TODO nao sei se aqui alguem ja explicou o super! precisa revisar!]

[code java]
public class SaldoInsuficienteException extends RuntimeException {	
	
	SaldoInsuficienteException(String message) {
		super(message);
	}
}
[/code]

Em vez de lançar um %%IllegalArgumentException%%, vamos lançar nossa própria exception, com 
uma mensagem que dirá "Saldo Insuficiente":

[code java]
void saca(double valor) {
	if (this.saldo < valor) {
		throw new SaldoInsuficienteException("Saldo Insuficiente, tente um valor menor");
	} else {
		this.saldo-=valor;		
	}		
}
[/code]

E, para testar, crie uma classe que deposite um valor e tente sacar um valor maior:

[code java]
public static void main(String[] args) {
	Conta cc = new ContaCorrente();
	cc.deposita(10);		
		
	try {
		cc.saca(100);
	} catch (SaldoInsuficienteException e) {
		System.out.println(e.getMessage());
	}
}
[/code]

Podemos transformar essa %%Exception%% de ::unchecked:: para ::checked::, obrigando a quem chama esse 
método a dar %%try-catch%%, ou %%throws%%:

[code java]
public class SaldoInsuficienteException extends Exception {	
	
	SaldoInsuficienteException(String message) {
		super(message);
	}
}
[/code]


[section Para saber mais: finally]

[index FINALLY]
Os blocos %%try%% e %%catch%% podem conter uma terceira cláusula chamada %%finally%% que indica o que 
deve ser feito após o término do bloco %%try%% ou de um %%catch%% qualquer.

É interessante colocar algo que é imprescindível de ser executado, caso o que você queria fazer tenha 
dado certo, ou não. O caso mais comum é o de liberar um recurso no finally, como um arquivo ou 
conexão com banco de dados, para que possamos ter a certeza de que aquele arquivo (ou conexão) vá ser 
fechado, mesmo que algo tenha falhado no decorrer do código.

No exemplo a seguir, o bloco %%finally%% será sempre executado, independentemente de tudo ocorrer bem 
ou de acontecer algum problema:

[code java]
try {
	// bloco try
} catch (IOException ex) {
	// bloco catch 1
} catch (SQLException sqlex) {
	// bloco catch 2
} finally {
	// bloco finally
}
[/code]

[section Exercícios: Exceções]

[exercise]
[question]
Na classe %%Conta%%, modifique o método %%deposita(double x)%%: Ele 
deve lançar uma exception chamada %%IllegalArgumentException%%, que já faz parte da biblioteca do 
java, sempre que o valor passado como argumento for inválido (por exemplo, quando for negativo).

[code java]
void deposita(double valor) {
	if (valor < 0) {
		throw new IllegalArgumentException();
	} else {
		this.saldo += valor - 0.10;		
	}		
}
[/code]

[/question]
[question]
Crie uma classe %%TestaDeposita%% com o método %%main%%. Crie uma %%ContaPoupanca%% e tente depositar 
valores inválidos:

[code java]
public static void main(String[] args) {
	Conta cp = new ContaPoupanca();
	cp.deposita(-100);
}
[/code]

O que acontece? Uma %%IllegalArgumentException%% é lançada uma vez que tentamos depositar um valor 
inválido. Adicione o %%try/catch%% para tratar o erro:

[code java]
public static void main(String[] args) {
	Conta cp = new ContaPoupanca();
	
	try {
		cp.deposita(-100);
	} catch (IllegalArgumentException e) {
		System.out.println("Você tentou depositar um valor inválido");
	}
}
[/code]

Atenção: se a sua classe %%ContaCorrente%% está reescrevendo o método
%%deposita%% e não utiliza do %%super.deposita%%, ela não lançará
a exception no caso do valor negativo! Você pode resolver isso
utilizando o %%super.deposita%%, ou fazendo apenas o teste com 
%%ContaPoupanca%%.
[/question]

[question]
Ao lançar a %%IllegalArgumentException%%, passe via construtor uma mensagem a ser exibida. Lembre que 
a %%String%% recebida como parâmetro é acessível depois via o método %%getMessage()%% herdado por 
todas as %%Exceptions%%.

[code java]
void deposita(double valor) {
	if (valor < 0) {
		throw new IllegalArgumentException("Você tentou depositar um valor negativo");
	} else {
		this.saldo += valor  - 0.10;		
	}		
}
[/code]

[/question]
[question]
Altere sua classe %%TestaDeposita%% para exibir a mensagem da exceção através da chamada do 
%%getMessage()%%:

[code java]
public static void main(String[] args) {
	Conta cp = new ContaPoupanca();
	
	try {
		cp.deposita(-100);
	} catch (IllegalArgumentException e) {
		System.out.println(e.getMessage());
	}
}
[/code]

[/question]
[question]
Crie sua própria %%Exception%%, %%ValorInvalidoException%%. Para isso, você precisa criar uma classe 
com esse nome que estenda de %%RuntimeException%%. 

[code java]
class ValorInvalidoException extends RuntimeException {

}
[/code]

Lance-a em vez de %%IllegalArgumentException%%.

Atenção: nem sempre é interessante criarmos um novo tipo de exception! Depende do caso. Neste aqui, 
seria melhor ainda utilizarmos %%IllegalArgumentException%%. A boa prática diz que devemos preferir
usar as já existentes do Java sempre que possível.
[/question]
[question]
(opcional) Coloque um construtor na classe %%ValorInvalidoException%% que receba valor inválido
que ele tentou passar (isto é, ele vai receber um %%double valor%%).

Quando estendemos uma classe, não herdamos seus construtores, mas podemos acessá-los através
da palavra chave %%super%% de dentro de um construtor. As exceções do Java possuem uma série
de construtores úteis para poder popula-las já com uma mensagem de erro. Então vamos criar
um construtor em %%ValorInvalidoException%% que delegue para o construtor de sua mãe. Essa
vai guardar essa mensagem para poder monstra-la ao ser invocado o método %%getMessage%%:

[note]
Durante esse exercicio é bom uma explicacaozinha na lousa a respeito desse recurso.
Vale a pena das a motivacao explicando porque construtores nao sao herdados (se fossem
herdados, voce poderia construir um objeto do tipo filho passando menos informacoes
que as realmente necessarias por ela, ja que a classe pai nao precisava dela, por exemplo).

Tambem é bom explicar que isso é bem usual, e talvez falar do menu source, generate
constructor using fields (ou Control 3  + gcuf).
[/note]

[code java]
class ValorInvalidoException extends RuntimeException {
	
	ValorInvalidoException(double valor) {
		super("Valor invalido: " + valor);
	}
	
}
[/code]

Dessa maneira, na hora de dar o %%throw new ValorInvalidoException%% você vai precisar passar 
esse valor como argumento:

[code java]
	if (valor < 0) {
		throw new ValorInvalidoException(valor);
	} 
[/code]

Atenção! Você pode se aproveitar do Eclipse para isso: comece já
passando o %%valor%% como argumento para o construtor da exception, e
o eclipse vai reclamar que não existe tal construtor. O quick fix
vai sugerir que ele seja construindo, poupando-lhe tempo!
 
[/question]

[question]
(opcional) Declare a classe %%ValorInvalidoException%% como filha direta de %%Exception%% em vez de 
%%RuntimeException%%. Ela passa a ser **checked**. O que isso resulta? 

Você vai precisar avisar que o seu método %%deposita()%% %%throws ValorInvalidoException%%, pois ela é 
uma ::checked:: exception. Além disso, quem chama esse método vai precisar tomar uma decisão entre 
%%try-catch%% ou %%throws%%. Faça uso do quick fix do Eclipse novamente!

Depois, retorne a exception para ::unchecked::, isto é, para ser filha de %%RuntimeException%%, pois
iremos utilizá-la assim em exercícios dos capítulos posteriores.
[/question]
[/exercise]

[section Desafios]

[exercise]
[question]
O que acontece se acabar a memória da java virtual machine? Como forçar isso?
[/question]
[/exercise]

[section Discussão em aula: catch e throws em Exception]

Existe uma péssima prática de programação em java que é a de escrever o %%catch%% e o %%throws%% 
com %%Exception%%.

Existem códigos que sempre usam %%Exception%% pois isso cuida de todos os possíveis erros. O maior 
problema disso é generalizar o erro. Se alguém joga algo do tipo %%Exception%% para quem o chamou, 
quem recebe não sabe qual o tipo específico de erro ocorreu e não vai saber como tratar o mesmo.

[note]
É uma discussao rapida... Nada de novo. Se quiser pecam pro pessoal
entrar no link do post do kung sobre exceptions, que esta algumas paginas atras.
[/note]