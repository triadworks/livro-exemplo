[chapter O pacote java.lang]
[quote "Nossas cabeças são redondas para que os pensamentos possam mudar de direção." -- Francis 
Piacaba]

Ao término desse capítulo, você será capaz de:
[list]
* utilizar as principais classes do pacote %%java.lang%% e ler a documentação padrão de projetos 
java;
* usar a classe %%System%% para obter informações do sistema;
* utilizar a classe %%String%% de uma maneira eficiente e conhecer seus detalhes;
* usar as classes wrappers (como %%Integer%%) e boxing;
* utilizar os métodos herdados de %%Object%% para generalizar seu conceito de objetos.
[/list]

[note]
* Se ainda nao abriu o javadoc do Java para eles, precisa abrir nesse momento.
* _System_ e _Math_ são bem simples
* lembrar que você não pode chamar _getSaldo()_ em uma referência a _Object_
* não precisa explicar muito como funciona o pool de _String_, mas mostrar que a _String_ é imutável.
* Não falar do hashCode(), deixar para comentar no capítulo de collections.
[/note]

[section Pacote java.lang]
[index JAVA.LANG]
Já usamos, por diversas vezes, as classes %%String%% e %%System%%. Vimos o sistema de pacotes do 
Java e nunca precisamos dar um %%import%% nessas classes. Isso ocorre porque elas estão dentro do 
pacote %%java.lang%%, que é **automaticamente importado** para você. É o **único pacote** com esta 
característica.

Vamos ver um pouco de suas principais classes.

[section Um pouco sobre a classe System]
A classe %%System%% possui uma série de atributos e métodos estáticos. Já usamos o
atributo %%System.out%%, para imprimir. 

Olhando a documentação, você vai perceber que o atributo %%out%% é do tipo %%PrintStream%%
do pacote %%java.io%%. Veremos sobre essa classe no próximo capítulo. Já podemos
perceber que poderíamos quebrar o %%System.out.println%% em duas linhas:

[code java]
PrintStream saida = System.out;
saida.println("ola mundo!");
[/code]

[note]
Legal comentar que a o out é atributo estatico e publico... Fale que
a sun fez publico no java 1.0, e que hoje em dia nao podem mais mudar pra 
privado porque quebraria muito codigo. A propria sun diz que esse atributo ser
publico foi um erro. 

Os alunos costumam confundir e dizer que println também é estático, ou ainda
que println é da classe System. Quebrar a linha em dois ajuda a perceber
esses erros.
[/note]

Ela também possui o atributo %%in%%, que lê da entrada padrão, porém só
consegue captar bytes:

[code java]
	int i = System.in.read();
[/code]

O código acima deve estar dentro de um bloco de %%try%% e %%catch%%, pois pode lançar uma exceção 
%%IOException%%. É útil ficar lendo de %%byte%% em %%byte%%? Trabalharemos mais
com a entrada padrão também no próximo capítulo.

[index SYSTEM.EXIT]
O %%System%% conta também com um método que simplesmente desliga a virtual machine, retornando um 
código de erro para o sistema operacional, é o %%exit%%.

[code java]
	System.exit(0);
[/code]

Veremos também um pouco mais sobre a classe %%System%% no próximo capítulo e no de %%Threads%%. 
Consulte a documentação do Java e veja outros métodos úteis da %%System%%.

[box A classe Runtime]
A classe %%Runtime%% possui um método para fazer uma chamada ao sistema operacional e rodar algum 
programa:

[code java]
	Runtime rt = Runtime.getRuntime();
	Process p = rt.exec("dir");
[/code]

Isto deve ser evitado ao máximo, já que gera uma dependência da sua aplicação com o sistema operacional 
em questão, perdendo a portabilidade entre plataformas. Em muitos casos, isso pode ser substituído por 
chamadas às bibliotecas do Java. Nesse caso, por exemplo, você tem um método %%list%% na classe %%File%% 
do pacote de entrada e saída, que veremos posteriormente. 

O método %%exec%% te retorna um %%Process%%, onde você é capaz de pegar a saída do programa, enviar 
dados para a entrada, entre outros.
[/box]

[section java.lang.Object]
Sempre quando declaramos uma classe, essa classe é **obrigada** a herdar de outra. Isto é, para toda 
classe que declararmos, existe uma superclasse. Porém, criamos diversas classes sem herdar de 
ninguém:

[code java]
	class MinhaClasse {

	}
[/code]

[index OBJECT]
Quando o Java não encontra a palavra chave %%extends%%, ele considera que você está herdando da 
classe %%Object%%, que também se encontra dentro do pacote %%java.lang%%. Você até mesmo pode 
escrever essa herança, que é o mesmo:

[code java]
	class MinhaClasse extends Object {

	}
[/code]

**Todas as classes, sem exceção, herdam de %%Object%%**, seja direta ou indiretamente, pois
ela é a mãe, vó, bisavó, etc de qualquer classe.

Podemos também afirmar que qualquer objeto em Java é um %%Object%%, podendo ser referenciado como 
tal. Então, qualquer objeto possui todos os métodos declarados na classe %%Object%% e veremos alguns 
deles logo após o ::casting::.

[note]
Importante os proprios alunos chegarem a essa conclusao. Voce pode fazer isso provocando-os
ao escrever %%Object o%% na lousa e perguntando a que objetos essa variável %%o%% pode se
referenciar! 
[/note]

[section Casting de referências]
A habilidade de poder se referir a qualquer objeto como %%Object%% nos traz muitas vantagens. Podemos 
criar um método que recebe um %%Object%% como argumento, isto é, qualquer objeto! Melhor, podemos 
armazenar qualquer objeto:

[code java]
	public class GuardadorDeObjetos {
		private Object[] arrayDeObjetos = new Object[100];
		private int posicao = 0;
	
		public void adicionaObjeto(Object object) {
			this.arrayDeObjetos[this.posicao] = object;
			this.posicao++;
		}
	
		public Object pegaObjeto(int indice) {
			return this.arrayDeObjetos[indice];
		}
	}
[/code]

[note]
Boa hora para perguntar quantos objetos são criados
enquanto escrevemos %%new Object[100]%% na lousa. Reforça o conhecimento
adquirido (e alguns se confundirao novamente, normal).
[/note]

Mas, e no momento que retirarmos uma referência a esse objeto, como vamos acessar os métodos e 
atributos desse objeto? Se estamos referenciando-o como %%Object%%, não podemos acessá-lo como sendo 
%%Conta%%. Veja o exemplo a seguir:

[code java]
	GuardadorDeObjetos guardador = new GuardadorDeObjetos();
	Conta conta = new Conta();
	guardador.adicionaObjeto(conta);

	// ...
	
	Object object = guardador.pegaObjeto(0); // pega a conta referenciado como objeto
	object.getSaldo(); // classe Object nao tem método getSaldo! não compila!

[/code]
Poderíamos então atribuir essa referência de %%Object%% para %%Conta%% para depois
invocar o %%getSaldo()%%? Tentemos:

[code java]
Conta contaResgatada = object;
[/code]

Nós temos certeza de que esse %%Object%% se refere a uma %%Conta%%, já que fomos nós que o 
adicionamos na classe que guarda objetos. Mas o compilador Java não tem garantias sobre isso! 
Essa linha acima não compila, pois nem todo %%Object%% é uma %%Conta%%.

[index CASTING DE REFERÊNCIAS]
Para realizar essa atribuição, para isso devemos "avisar" o compilador Java que realmente queremos
fazer isso, sabendo do risco que corremos. Fazemos o **casting de referências**, parecido com 
de tipos primitivos:

[code java]
Conta contaResgatada = (Conta) object;
[/code]

O código passa a compilar, mas será que roda? Esse código roda sem nenhum problema, pois em 
tempo de execução a JVM verificará se essa referência realmente é para um objeto de tipo %%Conta%%, 
e está! Se não estivesse, uma exceção do tipo %%ClassCastException%% seria lançada.

[note]
Atenção! O problema aqui poderia ser resolvido através da parametrização da classe 
%%GuardadorDeObjetos%%. Se alguem perguntar se da para fugir do casting, diga
que veremos no capitulo de coleções o uso do generics.

Se voce for mostrar pra alguem, so tome cuidado porque nao se pode dar new em
array de tipo generico (%%new T[100]%%), tem de dar em %%Object[100]%% e fazer casting,
por causa da ausencia de reificacao no generics do java.
[/note]

Poderíamos fazer o mesmo com %%Funcionario%% e %%Gerente%%. Tendo uma referência para um 
%%Funcionario%% que temos certeza ser um %%Gerente%%, podemos fazer a atribuição, desde que o 
casting exista, pois nem todo %%Funcionario%% é um %%Gerente%%.

[code java]
	Funcionario funcionario = new Gerente();

	//	 ... e depois

	Gerente gerente = funcionario; // não compila! 
					     // nem todo Funcionario é um Gerente

[/code]

O correto então seria:

[code java]
Gerente gerente = (Gerente) funcionario;
[/code]

Vamos misturar um pouco:

[code java]
	Object object = new Conta();
	
	//	 ... e depois

	Gerente gerente = (Gerente) object;
[/code]

Esse código compila? Roda?

Compila, pois existe a chance de um %%Object%% ser um %%Gerente%%. Porém não roda, ele vai lançar
uma %%Exception%% (%%ClassCastException%%) em tempo de  execução. É importante diferenciar tempo 
de compilação e tempo de execução.

Neste exemplo, nós garantimos ao java que nosso Objeto %%object%% era um %%Gerente%% com o casting, 
por isso compilou, mas na hora de rodar, quando ele foi receber um %%Gerente%%, ele recebeu uma 
%%Conta%%, daí ele reclamou lançando %%ClassCastException%%!

[section Métodos do java.lang.Object: equals e toString]
[index TOSTRING]
O primeiro método interessante é o %%toString%%. As classes podem reescrever esse método para mostrar 
uma mensagem, uma %%String%%, que o represente. Você pode usá-lo assim:

[code java]
	Conta c = new Conta();
	System.out.println(c.toString());
[/code]

O método %%toString%% do %%Object%% retorna o nome da classe %%@%% um número de identidade:

[code]
Conta@34f5d74a
[/code]

Mas isso não é interessante para nós. Então podemos reescrevê-lo:

[code java]
	class Conta {
		private double saldo;
		// outros atributos...
	
		public Conta(double saldo) {
			this.saldo = saldo;
		}
	
		public String toString() {
			return "Uma conta com valor: " + this.saldo;
		}	
	}
[/code]

Chamando o %%toString%%:
[code java]
	Conta c = new Conta(100);
	System.out.println(c.toString()); //imprime: Uma conta com valor: 100.
[/code]

E o melhor, se for apenas para jogar na tela, você nem precisa chamar o %%toString%%! Ele já é 
chamado para você:

[code java]
	Conta c = new Conta(100);
	System.out.println(c); // O toString é chamado pela classe PrintStream
[/code]

Gera o mesmo resultado! 

Você ainda pode concatenar %%Strings%% em Java com o operador %%+%%. Se o Java encontra um objeto no 
meio da concatenação, ele também chama o %%toString%% dele.

[code java]
	Conta c = new Conta(100);
	System.out.println("descrição: " + c);
[/code]

O outro método muito importante é o %%equals%%. Quando comparamos duas variáveis referência no Java, 
o %%==%% verifica se as duas referem-se ao mesmo objeto:

[code java]
	Conta c1 = new Conta(100);
	Conta c2 = new Conta(100);
	if (c1 != c2) {
		System.out.println("objetos referenciados são diferentes!");
	}
[/code]

E, nesse caso, realmente são diferentes.

[index EQUALS]
Mas, e se fosse preciso comparar os atributos? Quais atributos ele deveria comparar? O Java por si 
só não faz isso, mas existe um método na classe %%Object%% que pode ser reescrito para criarmos esse 
critério de comparação. Esse método é o %%equals%%.

O %%equals%% recebe um %%Object%% como argumento e deve verificar se ele mesmo é igual ao %%Object%% 
recebido para retornar um %%boolean%%. Se você não reescrever esse método, o comportamento herdado é 
fazer um %%==%% com o objeto recebido como argumento.

[code java]
	public class Conta {
		private double saldo;
		// outros atributos...
	
		public Conta(double saldo) {
			this.saldo = saldo;
		}
	
		public boolean equals(Object object) {
			Conta outraConta = (Conta) object;
			if (this.saldo == outraConta.saldo) {
				return true;
			}
			return false;
		}
	
		public String toString() {
			return "Uma conta com valor: " + this.saldo;
		}
	}
[/code]

Um exemplo clássico do uso do %%equals%% é para datas. Se você criar duas datas, isto é, dois 
objetos diferentes, contendo %%31/10/1979%%, ao comparar com o %%==%% receberá %%false%%, pois são 
referências para objetos diferentes. Seria correto, então, reescrever este método, fazendo as 
comparações dos atributos, e o usuário passaria a invocar %%equals%% em vez de comparar com %%==%%.

Você poderia criar um método com outro nome em vez de reescrever %%equals%% que recebe %%Object%%, mas 
ele é importante pois muitas bibliotecas o chamam através do polimorfismo, como veremos no capítulo 
do %%java.util%%.

O método %%hashCode()%% anda de mãos dadas com o método %%equals()%% e é de fundamental entendimento 
no caso de você utilizar suas classes com estruturas de dados que usam tabelas de espalhamento. 
Também falaremos dele no capítulo de %%java.util%%.

[box Regras para a reescrita do método equals]
Pelo contrato definido pela classe %%Object%% devemos retornar %%false%% também no caso do objeto
passado não ser de tipo compatível com a sua classe. Então antes de fazer o casting devemos verificar
isso, e para tal usamos a palavra chave %%instanceof%%, ou teríamos uma exception sendo lançada.

Além disso, podemos resumir nosso %%equals%% de tal forma a não usar um %%if%%:

[code java]
		public boolean equals(Object object) {
			if (!(object instanceof Conta)) 
				return false;
			Conta outraConta = (Conta) object;
			return this.saldo == outraConta.saldo;
		}
[/code]
[/box]

[section Integer e classes wrappers (box)]
Uma pergunta bem simples que surge na cabeça de todo programador ao aprender uma nova linguagem é: 
"Como transformar um número em %%String%% e vice-versa?".

Cuidado! Usamos aqui o termo "transformar", porém o que ocorre não é uma transformação entre os 
tipos e sim uma forma de conseguirmos uma %%String%% dado um %%int%% e vice-versa. O jeito mais 
simples de transformar um número em %%String%% é concatená-lo da seguinte maneira:

[code java]
	int i = 100;
	String s = "" + i;
	System.out.println(s);

	double d = 1.2;
	String s2 = "" + d;
	System.out.println(s2);
[/code]

Para formatar o número de uma maneira diferente, com vírgula e número de casas decimais devemos 
utilizar outras classes de ajuda (%%NumberFormat%%, %%Formatter%%).

Para transformar uma %%String%% em número, utilizamos as classes de ajuda para os tipos primitivos 
correspondentes. Por exemplo, para transformar a %%String s%% em um número inteiro utilizamos o 
método estático da classe %%Integer%%:

[code java]
	String s = "101";
	int i = Integer.parseInt(s);
[/code]

As classes %%Double%%, %%Short%%, %%Long%%, %%Float%% etc contêm o mesmo tipo de método, como 
%%parseDouble%% e %%parseFloat%% que retornam um %%double%% e %%float%% respectivamente.

[index WRAPPING]
Essas classes também são muito utilizadas para fazer o **wrapping** (embrulho) de tipos primitivos 
como objetos, pois referências e tipos primitivos são incompatíveis. Imagine que precisamos passar 
como argumento um inteiro para o nosso guardador de objetos. Um inteiro não é um %%Object%%, como 
fazer?

[code java]
	int i = 5;
	Integer x = new Integer(i);
	guardador.adiciona(x);
[/code]

E, dado um %%Integer%%, podemos pegar o %%int%% que está dentro dele (desembrulhá-lo):

[code java]
	int i = 5;
	Integer x = new Integer(i);
	int numeroDeVolta = x.intValue();
[/code]

[section Autoboxing no Java 5.0]
[index AUTOBOXING]
Esse processo de wrapping e unwrapping é entediante. O Java 5.0 em diante traz um recurso chamado de 
**autoboxing**, que faz isso sozinho para você, custando legibilidade:

[code java]
	Integer x = 5;
	int y = x;
[/code]

No Java 1.4 esse código é inválido. No Java 5.0 em diante ele compila perfeitamente. É importante ressaltar 
que isso não quer dizer que tipos primitivos e referências sejam do mesmo tipo, isso é 
simplesmente um "açúcar sintático" (::syntax sugar::) para facilitar a codificação.

Você pode fazer todos os tipos de operações matemáticas com os wrappers, porém corre o risco 
de tomar um %%NullPointerException%%.

Você pode fazer o autoboxing diretamente para %%Object%% também, possibilitando passar um tipo 
primitivo para um método que receber %%Object%% como argumento:

[code java]
	Object o = 5;
[/code]

[note]
Voce nao deve entrar nesse detalhe, mas fique atento que esse autoboxing é feito
atraves de %%Integer.valueOf(5)%% (Integer, no JDK da Sun, faz cache de -128 a 127),
ja Double nao faz, por exemplo.
[/note]

[section java.lang.String]

%%String%% é uma classe em Java. Variáveis do tipo %%String%% guardam referências a objetos, e não 
um valor, como acontece com os tipos primitivos.

Aliás, podemos criar uma %%String%% utilizando o %%new%%:

[code java]
	String x = new String("fj11");
	String y = new String("fj11");
[/code]

Criamos aqui, dois objetos diferentes. O que acontece quando comparamos essas duas referências 
utilizando o %%==%%?

[code java]
	if (x == y) {
		System.out.println("referência para o mesmo objeto");
	}
	else {
		System.out.println("referências para objetos diferentes!");
	}
[/code]

Temos aqui dois objetos diferentes! E, então, como faríamos para verificar se o conteúdo do objeto é 
o mesmo? Utilizamos o método %%equals%%, que foi reescrito pela %%String%%, para fazer a comparação 
de %%char%% em %%char%%.

[code java]
	if (x.equals(y)) {
		System.out.println("consideramos iguais no critério de igualdade");
	}
	else {
		System.out.println("consideramos diferentes no critério de igualdade");
	}
[/code]

Aqui, a comparação retorna verdadeiro. Por quê? Pois quem implementou a classe %%String%% decidiu que 
este seria o melhor critério de comparação. Você pode descobrir os critérios de igualdade de cada 
classe pela documentação.

Podemos também concatenar %%Strings%% usando o %%+%%. Podemos concatenar %%Strings%% com qualquer 
objeto, até mesmo  números:

[code java]
	int total = 5;
	System.out.println("o total gasto é: " + total);
[/code]

O compilador utilizará os métodos apropriados da classe %%String%% e das classes wrappers para
realizar tal tarefa.

[index SPLIT]
A classe %%String%% conta também com um método %%split%%, que divide a %%String%% em um array de 
%%Strings%%, dado determinado critério.

[code java]
	String frase = "java é demais";
	String palavras[] = frase.split(" ");
[/code]

[index COMPARE TO]
Se quisermos comparar duas Strings, utilizamos o método %%compareTo%%, que recebe uma %%String%% como 
argumento e devolve um inteiro indicando se a %%String%% vem antes, é igual ou vem depois da 
%%String%% recebida. Se forem iguais, é devolvido %%0%%; se for anterior à %%String%% do argumento, 
devolve um inteiro negativo; e, se for posterior, um inteiro positivo.

Fato importante: **uma String é imutável**. O java cria um pool de Strings para usar como cache e, se 
a %%String%% não fosse imutável, mudando o valor de uma %%String%% afetaria todas as %%String%%s de outras 
classes que tivessem o mesmo valor.

Repare no código abaixo:

[code java]
	String palavra = "fj11";
	palavra.toUpperCase();
	System.out.println(palavra);
[/code]

Pode parecer estranho, mas ele imprime "fj11" em minúsculo. Todo método que parece alterar o valor 
de uma %%String%%, na verdade, cria uma nova %%String%% com as mudanças solicitadas e a retorna! Tanto
que esse método não é %%void%%. O código realmente útil ficaria assim:

[code java]
	String palavra = "fj11";
	String outra = palavra.toUpperCase();
	System.out.println(outra);
[/code]

Ou você pode eliminar a criação de outra variável temporária, se achar conveniente:

[code java]
	String palavra = "fj11";
	palavra = palavra.toUpperCase();
	System.out.println(palavra);
[/code]

Isso funciona da mesma forma para **todos** os métodos que parecem alterar o conteúdo de uma %%String%%.

Se você ainda quiser trocar o número 1 para 2, faríamos:

[code java]
	String palavra = "fj11";
	palavra = palavra.toUpperCase();
	palavra = palavra.replace("1", "2");
	System.out.println(palavra);
[/code]

Ou ainda podemos concatenar as invocações de método, já que uma %%String%% é devolvida a cada invocação:

[code java]
	String palavra = "fj11";
	palavra = palavra.toUpperCase().replace("1", "2");
	System.out.println(palavra);
[/code]

O funcionamento do pool interno de Strings do Java tem uma série de detalhes e você pode encontrar 
mais informações sobre isto na documentação da classe %%String%% e no seu método 
%%intern()%%.

[box Outros métodos da classe %%String%%]
Existem diversos métodos da classe %%String%% que são extremamente importantes. Recomendamos sempre 
consultar o javadoc relativo a essa classe para aprender cada vez mais sobre a mesma.

Por exemplo, o método %%charAt(i)%%, retorna o caractere existente na posição %%i%% da String, o 
**método** %%length%% retorna o número de caracteres na mesma e o método %%substring%% que recebe um 
%%int%% e devolve a SubString a partir da posição passada por aquele %%int%%.

O %%indexOf%% recebe um char ou uma String e devolve o índice em que aparece pela primeira vez na String
principal (há também o %%lastIndexOf%% que devolve o índice da última ocorrência).

O %%toUpperCase%% e o %%toLowerCase%% devolvem uma nova String toda em maiúscula e toda em minúscula,
respectivamente.

A partir do Java 6, temos ainda o método %%isEmpty%%, que devolve %%true%% se a String for vazia ou 
%%false%% caso contrário.

Alguns métodos úteis para buscas são o %%contains%% e o %%matches%%.

Há muitos outros métodos, recomendamos que você sempre consulte o javadoc da classe.
[/box]

[box java.lang %%StringBuffer%% e %%StringBuilder%%]
Como a classe %%String%% é imutável, trabalhar com uma mesma %%String%% diversas vezes pode ter um efeito colateral:
gerar inúmeras %%String%%s temporárias. Isto prejudica a performance da aplicação consideravelmente.

No caso de você trabalhar muito com a manipulação de uma mesma %%String%% (por exemplo, dentro de um laço), o
ideal é utilizar a classe %%StringBuffer%%. A classe %%StringBuffer%% representa uma sequência de caracteres.
Diferentemente da %%String%%, ela é mutável, e não possui aquele pool. 

A classe %%StringBuilder%% tem exatamente os mesmos métodos, com a diferença dela não ser **thread-safe**. Veremos
sobre este conceito no capítulo de Threads.
[/box]

[section java.lang.Math]
[index MATH]
Na classe %%Math%%, existe uma série de métodos estáticos que fazem operações com números como, por 
exemplo, arredondar(%%round%%), tirar o valor absoluto (%%abs%%), tirar a raiz(%%sqrt%%), calcular o 
seno(%%sin%%) e outros.

[code java]
	double d = 4.6;
	long i = Math.round(d);

	int x = -4;
	int y = Math.abs(x);
[/code]

Consulte a documentação para ver a grande quantidade de métodos diferentes.

No Java 5.0, podemos tirar proveito do %%import static%% aqui:
[code java]
	import static java.lang.Math.*;
[/code]

Isso elimina a necessidade de usar o nome da classe, sob o custo de legibilidade:
[code java]
	double d = 4.6;
	long i = round(d);
	int x = -4;
	int y = abs(x);
[/code]

[section Exercícios: java.lang]
Aqui faremos diversos testes, além de modificar a classe %%Conta%%. Você pode fazer
todos esses exercícios dentro do próprio projeto %%banco%%.

[exercise]

[question]
Teste os exemplos desse capítulo, para ver que uma %%String%% é imutável. Por exemplo:

[code java]
	public class TestaString {
	
		public static void main(String[] args) {
			String s = "fj11";
			s.replaceAll("1", "2");
			System.out.println(s);
		}
	
	}
[/code]

Como fazer para ele imprimir fj22?
[/question]

[question]
Como fazer para saber se uma %%String%% se encontra dentro de outra? 
E para tirar os espaços em branco de uma %%String%%? E para saber
se uma %%String%% está vazia? E para saber quantos caracteres
tem uma %%String%%?

Tome como hábito sempre pesquisar o javadoc! Conhecer a API, aos
poucos, é fundamental para que você não precise reescrever a roda! 
[/question]

[question]
Crie uma classe %%TestaInteger%% e vamos fazer comparações com Integers dentro do %%main%%:

[code java]
Integer x1 = new Integer(10);
Integer x2 = new Integer(10);

if (x1 == x2) {
	System.out.println("igual");
} else {
	System.out.println("diferente");
}
[/code]

[note]
Cuidado com o autoboxing aqui! se voce nao usar o %%new%%, vai dar %%true%%,
pois o Java faz um cache de %%Integer%%, e o autoboxing nao faz new, ele usa o
metodo %%Integer valueOf(int)%% que passa por esse cache. Mas se voce usar um numero
alto, ele nao usara o cache, e dara %%false%% (o cache da Sun vai de -128 a 127, mas isso
pode variar entre implementacoes, teoricamente). É algo parecido com a %%String%%:
nao da pra confiar no %%==%% sempre, mas as vezes funciona, entao nao use!.
[/note]

E se testarmos com o %%equals%%?

O que podemos concluir? Como verificar se a classe %%Integer%% também reescreve
o método %%toString%%?

A maioria das classes do Java que são muito utilizadas terão seus métodos %%equals%%
e %%toString%% reescritos convenientemente.

Aproveite e faça um teste com o método estático %%parseInt%%, recebendo uma String
válida e uma inválida (com caracteres alfabéticos), e veja o que acontece! 
[/question]

[question]
Utilize-se da documentação do Java e descubra de que classe é o objeto referenciado pelo atributo 
%%out%% da %%System%%.

Repare que, com o devido %%import%%, poderíamos escrever:

[code java]
	// falta a declaração da saída
	saida = System.out;
	saida.println("ola");
[/code]

A variável %%saida%% precisa ser declarada de que tipo? É isso 
que você precisa descobrir. Se você digitar esse código no Eclipse, ele
vai te sugerir um quickfix e declarará a variável para você. 

Estudaremos essa classe no capítulo seguinte.
[/question]

[question]
Crie e imprima uma referência para %%Conta%% (%%ContaCorrente%% ou %%ContaPoupanca%%,
no caso de sua %%Conta%% ser abstrata):

[code java]
	Conta conta = new ContaCorrente():
	System.out.println(conta);
[/code]

O que acontece?
[/question]

[question]
Reescreva o método %%toString%% da sua classe %%Conta%% fazendo com que uma mensagem mais propícia
seja devolvida. Lembre-se de aproveitar dos recursos do Eclipse para isto: digitando apenas o começo do nome
do método a ser reescrito e pressionando %%Ctrl+espaço%%, ele vai sugerir reescrever o método, poupando você
do trabalho de escrever a assinatura do mesmo, e de cometer algum engano.

[code java]
public abstract class Conta {
		
	private double saldo;
		
	public String toString() {	
		return "esse objeto é uma conta com saldo R$" + this.saldo;
	}
		
	// restante da classe
		
}
[/code]

Imprima novamente uma referência a %%Conta%%. O que aconteceu?

[/question]
[question]
Reescreva o método %%equals%% da classe %%Conta%% para que duas contas com o mesmo **número de conta** 
sejam consideradas iguais. Para isso, você vai precisar de um atributo %%numero%%. Esboço:

[code java]
	abstract class Conta {
		private int numero;
		
		public boolean equals(Object obj) {
			Conta outraConta = (Conta) obj;
			
			return this.numero == outraConta.numero;
		}
	
		// restante	, colocar getter e setter para numero, usando Eclipse!	
	}
[/code]

[note]
Bom momento para falar do instanceof, ja que pelo contrato do Object.equals
voce deve retornar false caso os tipos nao sejam ok. 

Se falar do instanceof, tome cuidado para nao animar os alunos a fazerem switches
baseados no tipo do objeto, e acabar virando programacao procedural.

Alternativa: fazer o casting com try/catch e return false dentro do catch
(embora dessa forma aceitemos poliformismo e tipos diferentes mas filhos sejam aceitos).
[/note]

Você pode usar o **Ctrl+espaço** do eclipse para escrever o esqueleto do
método %%equals%%, basta digitar dentro da classe %%equ%% e pressionar **Ctrl+espaço**.

Crie uma classe %%TestaComparacaoConta%%, e dentro do %%main%% compare duas instâncias 
de %%ContaCorrente%% com %%==%%, depois com %%equals%%, 
sendo que as instâncias são diferentes mas possuem o mesmo %%numero%% de conta (use
o %%setNumero%%). 
[/question]

[question]
	Um %%double%% não está sendo suficiente para guardar a quantidade de casas necessárias em uma 
	aplicação. Preciso guardar um número decimal muito grande! O que poderia usar? (consulte a 
	documentação, tente adivinhar onde você pode encontrar algo desse tipo pelos nomes dos pacotes, veja 
	como é intuitivo).
	
	O %%double%% também tem problemas de precisão ao fazer contas, por causa de arredondamentos
	da aritmética de ponto flutuante definido pela IEEE 754:
	
	http://en.wikipedia.org/wiki/IEEE_754
	
	Ele não deve ser usado se você precisa realmente de muita precisão (casos que envolvam dinheiro,
	por exemplo).
	
	Lembre-se: no Java há muito já pronto. Seja na biblioteca padrão, seja em bibliotecas
	open source que você pode encontrar pela internet.
[/question]
[question]
	(opcional) Faça com que o %%equals%% da sua classe %%Conta%% também leve em consideração a 
	%%String%% do nome do cliente a qual ela pertence. Se sua %%Conta%% não
	possuir o atributo %%nome%%, crie-o. Teste se o método criado está funcionando
	corretamente.
[/question]
[question]
	(opcional) Crie a classe %%GuardadorDeObjetos%% como visto nesse capítulo. 
	Crie uma classe %%TestaGuardador%% e dentro do %%main%% crie uma %%ContaCorrente%% 
	e adicione-a em um %%GuardadorDeObjetos%%. Depois teste pegar essa referência 
	como %%ContaPoupanca%%, usando casting. Repare na exception que é lançada:
	
	[code java]	
	GuardadorDeObjetos guardador = new GuardadorDeObjetos();
	ContaCorrente cc = new ContaCorrente();
	guardador.adicionaObjeto(cc);

	// vai precisar do casting para compilar!
	// use Ctrl+1 para o Eclipse gerar para você
	ContaPoupanca cp = guardador.pega(0); 	 
	[/code]	
	
	Teste também o autoboxing do Java 5.0, passando um inteiro para nosso guardador.
[/question]

[question]
	(opcional) Escreva um método que usa os métodos %%charAt%% e %%length%% de uma %%String%% para 
	imprimir a mesma caractere a caractere, com cada caractere em uma linha diferente.
[/question]
[question]
	(opcional) Reescreva o método do exercício anterior, mas imprima a %%String%% de trás para a 
	frente. Teste-a para ::"Socorram-me, subi no ônibus em Marrocos":: e ::"Anotaram a data da maratona"::.
	
	[note]
	Sempre foi meu sonho usar a frase ::"Socorram-me, subi no ônibus em Marrocos"::
	com fins profissionais. Estou realizado. Paulo Silveira.
	[/note]
[/question]
[question]
	(opcional) Dada uma frase, reescreva essa frase com as palavras na ordem invertida.
	::"Socorram-me, subi no ônibus em Marrocos":: deve retornar ::"Marrocos em ônibus no subi Socorram-me,"::.
	Utilize o método %%split%% da %%String%% para te auxiliar.
[/question]
[question]
	(opcional) Pesquise a classe %%StringBuilder%% (ou StringBuffer no Java 1.4). Ela é mutável. Por que 
	usá-la em vez da %%String%%? Quando usá-la? Repare que ela tem um método %%reverse%% e outros bem
	úteis!
[/question]
[/exercise]

[note]
Essas ultimas questoes sao para acostumar o usuario a usar o javadoc e conhecer mais
a api da String, que sera fundamental no seu dia a dia.
[/note]

[section Desafio]
[exercise]
[question]
	Converta uma %%String%% para um número sem usar as bibliotecas do java que já fazem isso. Isso é, 
	uma %%String x = "762"%% deve gerar um %%int i = 762%%.
	
	Para ajudar, saiba que um %%char%% pode ser "transformado" em %%int%% com o mesmo
	valor numérico fazendo:
	
	[code java]
		char c = '3';
		int i = c - '0'; // i vale 3! 		
	[/code] 
	
	Aqui estamos nos aproveitando do conhecimento da tabela unicode:
	os números de 0  a 9 estão em sequência! Você poderia usar
	o método estático %%Character.getNumericValue(char)%% em vez disso.
[/question]
[/exercise]


[section Discussão em aula: O que você precisa fazer em Java?]

Qual é a sua necessidade com o Java? Precisa fazer algoritmos
de redes neurais? Gerar gráficos 3D? Relatórios em PDF? Gerar
código de barra? Gerar boletos? Validar CPF? Mexer com
um arquivo do excel?

O instrutor vai mostrar que para a maioria absoluta das suas
necessidades, alguém já fez uma biblioteca e a disponibilizou.

[note]
Nao sei porque, mas muita gente conhece redes neurais: falar do joone;
Graficos: jfreechart, falar do apendice;
algoritmos geneticos: JGAP;
Relatorios: birt e jasper;
Excel: apache POI;
Boleto, código de barras, validadores e formatadores: Stella
[/note]