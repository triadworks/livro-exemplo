[chapter Orientação a Objetos - Interfaces]

[quote "Uma imagem vale mil palavras. Uma interface vale mil imagens." -- Ben Shneiderman]

Ao término desse capítulo, você será capaz de:

[list]
* dizer o que é uma interface e as diferenças entre herança e implementação;
* escrever uma interface em Java;
* utilizá-las como um poderoso recurso para diminuir acoplamento entre as classes.
[/list]

[note]
* utilizar os exemplos de _Connection_ e _Comparable_, apenas bem por cima, podem ajudar os alunos a 
enxergar o uso de interfaces. Em especial _Comparable_, pois qualquer classe pode implementar 
sem ter a *menor* similaridade com outra classe que também a implementa (nao eh bem assim com generics). 
Um exemplo é _ContaCorrente_ e _String_.
* pode usar a comparacao de que interface é uma classe muito abstrata,
mas tome cuidado... precisa deixar explicito que interface nao é uma classe,
nao ha uma heranca de implementacao.
[/note]

[section Aumentando nosso exemplo]
[note]
	Dar o problema de Diretor tbm ter o autentica e faze-los chegar na solucao do
	FuncionarioAutenticavel. Mostrar que eles conseguiram solucionar com o que ja sabiam.
	
	Ai piora o problema e coloca o Cliente tbm. Alguem vai falar "Cliente extends FuncionarioAutenticavel",
	comente "Gato extends Cachorro" só pq tem patas?
	
	Esclarecer qual o problema que temos: Como garantir que uma classe tenha um método que eu quero? 
	Como achar um fator comum?
[/note]


Imagine que um Sistema de Controle do Banco pode ser acessado, além de pelos Gerentes, pelos 
Diretores do Banco. Então, teríamos uma classe %%Diretor%%:

[code java]
class Diretor extends Funcionario {

	public boolean autentica(int senha) {
		// verifica aqui se a senha confere com a recebida como parametro
	}

}
[/code]

E a classe %%Gerente%%:

[code java]
class Gerente extends Funcionario {
	
	public boolean autentica(int senha) {
		// verifica aqui se a senha confere com a recebida como parametro
		// no caso do gerente verifica tambem se o departamento dele
		// tem acesso
	}

}
[/code]

[img images/interfaces/heranca_basico.png w=50]

Repare que o método de autenticação de cada tipo de %%Funcionario%% pode variar muito. Mas vamos aos 
problemas. Considere o %%SistemaInterno%% e seu controle: precisamos receber um %%Diretor%% ou 
%%Gerente%% como argumento, verificar se ele se autentica e colocá-lo dentro do sistema.

[code java]
class SistemaInterno {
	
	void login(Funcionario funcionario) {
		// invocar o método autentica? não da! Nem todo Funcionario tem
	}
}
[/code]

O %%SistemaInterno%% aceita qualquer tipo de %%Funcionario%%, tendo ele acesso ao sistema ou não, mas 
note que nem todo %%Funcionario%% possui o método %%autentica%%. Isso nos impede de chamar esse 
método com uma referência apenas a %%Funcionario%% (haveria um erro de compilação). O que fazer 
então? 

[code java]
class SistemaInterno {
	
	void login(Funcionario funcionario) {
		funcionario.autentica(...); // não compila
	}
}
[/code]

Uma possibilidade é criar dois métodos %%login%% no %%SistemaInterno%%: um para receber %%Diretor%% e 
outro para receber %%Gerente%%. Já vimos que essa não é uma boa escolha. Por quê?

[code java]
class SistemaInterno {
	
	// design problemático
	void login(Diretor funcionario) {
		funcionario.autentica(...);
	}

	// design problemático
	void login(Gerente funcionario) {
		funcionario.autentica(...);
	}

}
[/code]

Cada vez que criarmos uma nova classe de %%Funcionario%% que é ::autenticável::, precisaríamos 
adicionar um novo método de login no %%SistemaInterno%%.

[index SOBRECARGA]
[box Métodos com mesmo nome]
Em Java, métodos podem ter o mesmo nome desde que não sejam ambíguos, isto é, que exista uma maneira 
de distinguir no momento da chamada.

Isso se chama **sobrecarga** de método. (**Overloading**. Não confundir com **overriding**, que é um 
conceito muito mais poderoso).
[/box]

Uma solução mais interessante seria criar uma classe no meio da árvore de herança, 
%%FuncionarioAutenticavel%%:

[code java]
class FuncionarioAutenticavel extends Funcionario {
	
	public boolean autentica(int senha) {
		// faz autenticacao padrao
	}

	// outros atributos e metodos
		
}
[/code]

As classes %%Diretor%% e %%Gerente%% passariam a estender de %%FuncionarioAutenticavel%%, e o 
%%SistemaInterno%% receberia referências desse tipo, como a seguir:

[code java]
class SistemaInterno {
	
	void login(FuncionarioAutenticavel fa) {

		int senha = //pega senha de um lugar, ou de um scanner de polegar

		// aqui eu posso chamar o autentica! 
		// Pois todo FuncionarioAutenticavel tem
		boolean ok = fa.autentica(senha);

	}
}
[/code]

[img images/interfaces/heranca_funcionario_autenticavel.png w=50]

Repare que %%FuncionarioAutenticavel%% é uma forte candidata a classe abstrata. Mais ainda, o método 
%%autentica%% poderia ser um método abstrato.

O uso de herança resolve esse caso, mas vamos a uma outra situação um pouco mais complexa: precisamos 
que todos os clientes também tenham acesso ao %%SistemaInterno%%. O que fazer? Uma opção é criar 
outro método %%login%% em %%SistemaInterno%%: mas já descartamos essa anteriormente.

Uma outra, que é comum entre os novatos, é fazer uma herança sem sentido para resolver o problema, 
por exemplo, fazer %%Cliente extends FuncionarioAutenticavel%%. Realmente, resolve o problema, mas 
trará diversos outros. %%Cliente%% definitivamente **não é** %%FuncionarioAutenticavel%%. Se você 
fizer isso, o %%Cliente%% terá, por exemplo, um método %%getBonificacao%%, um atributo salario e 
outros membros que não fazem o menor sentido para esta classe! Não faça herança quando a relação não 
é estritamente "é um".

[todo Mudar a imagem heranca_sem_sentido.png]
[img images/interfaces/heranca_sem_sentido.png w=65]

Como resolver essa situação? Note que conhecer a sintaxe da linguagem não é o suficiente, precisamos 
estruturar/desenhar bem a nossa estrutura de classes.

[section Interfaces]

O que precisamos para resolver nosso problema? Arranjar uma forma de poder referenciar %%Diretor%%, 
%%Gerente%% e %%Cliente%% de uma mesma maneira, isto é, achar um fator comum.

Se existisse uma forma na qual essas classes garantissem a existência de um determinado método, 
através de um contrato, resolveríamos o problema.

Toda classe define 2 itens:

[list]
* o que uma classe faz (as assinaturas dos métodos)
* como uma classe faz essas tarefas (o corpo dos métodos e atributos privados)
[/list]

[index CONTRATO]
Podemos criar um "contrato" que define tudo o que uma classe deve fazer se quiser ter um determinado 
status. Imagine:

[code]
contrato Autenticavel:
    
		quem quiser ser Autenticavel precisa saber fazer:
			1.autenticar dada uma senha, devolvendo um booleano
[/code]

Quem quiser, pode "assinar" esse contrato, sendo assim obrigado a explicar como será feita essa 
autenticação. A vantagem é que, se um %%Gerente%% assinar esse contrato, podemos nos referenciar a 
um %%Gerente%% como um %%Autenticavel%%.

Podemos criar esse contrato em Java!

[code java]
interface Autenticavel {
	
	boolean autentica(int senha);
	
}
[/code]

[index INTERFACE]
Chama-se %%interface%% pois é a maneira pela qual poderemos conversar com um %%Autenticavel%%. 
Interface é a maneira através da qual conversamos com um objeto.

Lemos a interface da seguinte maneira: ::"quem desejar ser autenticável precisa saber autenticar 
dado um inteiro e retornando um booleano"::. Ela é um contrato onde quem assina se responsabiliza 
por implementar esses métodos (cumprir o contrato).

Uma interface pode definir uma série de métodos, mas nunca conter implementação deles. Ela só expõe 
**o que o objeto deve fazer**, e não **como ele faz**, nem **o que ele tem**. **Como ele faz** vai 
ser definido em uma **implementação** dessa interface.

[index IMPLEMENTS]
E o %%Gerente%% pode "assinar" o contrato, ou seja, **implementar** a interface. No momento em que 
ele implementa essa interface, ele precisa escrever os métodos pedidos pela interface (muito parecido 
com o efeito de herdar métodos abstratos, aliás, métodos de uma interface são públicos e abstratos, 
sempre). Para implementar usamos a palavra chave %%implements%% na classe:

[code java]
class Gerente extends Funcionario implements Autenticavel {
	
	private int senha;
	
	// outros atributos e métodos
		
	public boolean autentica(int senha) {
		if(this.senha != senha) {
			return false;
		}
		// pode fazer outras possiveis verificacoes, como saber se esse 
		// departamento do gerente tem acesso ao Sistema
	
		return true;
	}
	
}
[/code]

[img images/interfaces/interface_autenticavel.png w=60]

O %%implements%% pode ser lido da seguinte maneira: "A classe %%Gerente%% se compromete a ser tratada 
como %%Autenticavel%%, sendo obrigada a ter os métodos necessários, definidos neste contrato".

[note]
Aqui voce deve fazer varias analogias?

Como usamos o celular? Através dos botoes (interface), independendo se é GSM ou CDMA (implementacao)

Como você usa o carro? Atraves das marchas e volates (interface), independendo se é alcool, 
gasolina ou eletricindade (implementacao).
Mas se voce for dirigir na inglaterra, com cambio do outro lado, vai ter de reaprender a dirigir
(quebra de interface).

Como voce usa o computador? Atraves do telcado, monitor e mouse (interface) pouco importa se é
Atlhon, Celeron, Pentium ou se o monitor é LCD ou CRT (implementacao)
[/note]

A partir de agora, podemos tratar um %%Gerente%% como sendo um %%Autenticavel%%. Ganhamos mais 
polimorfismo! Temos mais uma forma de referenciar a um %%Gerente%%. Quando crio uma variável do tipo 
%%Autenticavel%%, estou criando uma referência para **qualquer** objeto de uma classe que implemente 
%%Autenticavel%%, direta ou indiretamente:

[code java]
Autenticavel a = new Gerente();
// posso aqui chamar o metodo autentica!
[/code]

Novamente, a utilização mais comum seria receber por argumento, como no nosso %%SistemaInterno%%:

[code java]
class SistemaInterno {	
  
  void login(Autenticavel a) {
     int senha = /v/pega senha de um lugar, ou de um scanner de polegar
     boolean ok =	a.autentica(senha);
     
     // aqui eu posso chamar o autentica! 
     // não necessariamente é um Funcionario! Mais ainda, eu não sei
     // que objeto a referência "a" está apontando exatamente! Flexibilidade.
  }
  
}
[/code]

Pronto! E já podemos passar qualquer %%Autenticavel%% para o %%SistemaInterno%%. Então precisamos 
fazer com que o %%Diretor%% também implemente essa interface.

[code java]
class Diretor extends Funcionario implements Autenticavel {
	
	// metodos e atributos, alem de obrigatoriamente ter o autentica
	
}
[/code]

[img images/interfaces/interface_autenticavel2.png w=80]

Podemos passar um %%Diretor%%. No dia em que tivermos mais um funcionário com acesso ao 
sistema, basta que ele implemente essa interface, para se encaixar no sistema. 

Qualquer %%Autenticavel%% passado para o %%SistemaInterno%% está bom para nós. Repare que pouco 
importa quem o objeto referenciado realmente é, pois ele tem um método %%autentica%% que é o 
necessário para nosso %%SistemaInterno%% funcionar corretamente. Aliás, qualquer outra classe que 
futuramente implemente essa interface poderá ser passada como argumento aqui.

[code java]
Autenticavel diretor = new Diretor();
Autenticavel gerente = new Gerente();
[/code]

Ou, se achamos que o %%Fornecedor%% precisa ter acesso, basta que ele implemente 
%%Autenticavel%%. Olhe só o tamanho do desacoplamento: quem escreveu o %%SistemaInterno%% só precisa 
saber que ele é %%Autenticavel%%.

[code java]
class SistemaInterno {	

  void login(Autenticavel a) {
	// não importa se ele é um gerente ou diretor
	// será que é um fornecedor?
	// Eu, o programador do SistemaInterno, não me preocupo
	// Invocarei o método autentica
  }

}
[/code]

Não faz diferença se é um %%Diretor%%, %%Gerente%%, %%Cliente%% ou qualquer classe que venha por aí. 
Basta seguir o contrato! Mais ainda, cada %%Autenticavel%% pode se autenticar de uma maneira 
completamente diferente de outro.

Lembre-se: a interface define que todos vão saber se autenticar (o que ele faz), enquanto a 
implementação define como exatamente vai ser feito (como ele faz).

A maneira como os objetos se comunicam num sistema orientado a objetos é muito mais importante do que 
como eles executam. **O que um objeto faz** é mais importante do que **como ele faz**. Aqueles que 
seguem essa regra, terão sistemas mais fáceis de manter e modificar. Como você já percebeu, esta é 
uma das idéias principais que queremos passar e, provavelmente, a mais importante de todo esse curso.

[box Herança entre interfaces]
Diferentemente das classes, uma interface pode herdar de mais de uma interface. É como um contrato 
que depende que outros contratos sejam fechados antes deste valer. Você não herda métodos e 
atributos, mas sim responsabilidades.
[/box]

[section Dificuldade no aprendizado de interfaces]

Interfaces representam uma barreira no aprendizado do Java: parece que estamos escrevendo um código 
que não serve pra nada, já que teremos essa linha (a assinatura do método) escrita nas nossas classes 
implementadoras. Essa é uma maneira errada de se pensar. O objetivo do uso de uma interface é deixar 
seu código mais flexível e possibilitar a mudança de implementação sem maiores traumas. **Não é 
apenas um código de prototipação, um cabeçalho**!

Os mais radicais dizem que toda classe deve ser "interfaceada", isto é, só devemos nos referir a 
objetos através de suas interfaces. Se determinada classe não tem uma interface, ela deveria ter. 
Os autores deste material acham tal medida radical demais, porém o uso de interfaces em vez de 
herança é amplamente aconselhado. Você pode encontrar mais informações sobre o assunto nos livros 
::Design Patterns::, ::Refactoring:: e ::Effective Java::.

No livro Design Patterns, logo no início, os autores citam 2 regras "de ouro". Uma é "evite herança, 
prefira composição" e a outra, "programe voltado a interface e não à implementação".

Veremos o uso de interfaces no capítulo de coleções, o que melhora o entendimento do assunto. O 
exemplo da interface %%Comparable%% também é muito esclarecedor, onde enxergamos o reaproveitamento 
de código através das interfaces, além do encapsulamento. Para o método %%Collections.sort()%%, pouco 
importa quem vai ser passado como argumento. Para ele, basta que a coleção seja de objetos 
comparáveis. Ele pode ordenar %%Elefante%%, %%Conexao%% ou %%ContaCorrente%%, desde que implementem 
%%Comparable%%.

[section Exemplo interessante: conexões com o banco de dados]

Como fazer com que todas as chamadas para bancos de dados diferentes respeitem a mesma regra? Usando 
interfaces!

Imagine uma interface %%Conexao%% contendo todos os métodos necessários para a comunicação e troca de 
dados com um banco de dados. Cada banco de dados fica encarregado de criar a sua implementação para 
essa interface.

Quem for usar uma %%Conexao%% não precisa se importar com qual objeto exatamente está trabalhando, já 
que ele vai cumprir o papel que toda %%Conexao%% deve ter. Não importa se é uma conexão com um Oracle 
ou MySQL.

[img images/interfaces/interface_banco_dados.png w=80]

Apesar do %%java.sql.Connection%% não trabalhar bem assim, a ideia é muito similar, porém as conexões 
vêm de uma ::factory:: chamada %%DriverManager%%.

Conexão a banco de dados está fora do escopo desse treinamento, mas é um dos primeiros tópicos 
abordados no curso FJ-21, juntamente com DAO.

[section Um pouco mais...]
[exercise]
	[question]
		Posso substituir toda minha herança por interfaces? Qual é a vantagem e a desvantagem?
	[/question]
	[question]
		Uma interface também pode declarar constantes (não atributos de objeto). Qual é a utilidade?
	[/question]
[/exercise]

[section Exercícios: Interfaces]
[exercise]
[question]
[note]
Nesse primeiro exercício, costumo falar que temos uma loja de tapetes
e vamos pagar um preco de acordo com quantos metros a area do tapete tiver.
[/note]

A sintaxe do uso de interfaces pode parecer muito estranha, à primeira vista. 

Vamos começar com um exercício para praticar a sintaxe. Crie um projeto
%%interfaces%% e crie a interface %%AreaCalculavel%%:

[code java]
interface AreaCalculavel {
	double calculaArea();
}
[/code]

Queremos criar algumas classes que são %%AreaCalculavel%%:

[code java]
class Quadrado implements AreaCalculavel {
	private int lado;
	
	public Quadrado(int lado) {
		this.lado = lado;
	}
	
	public double calculaArea() {
		return this.lado * this.lado;
	}
}
[/code]

[code java]
class Retangulo implements AreaCalculavel {
	private int largura;
	private int altura;
	
	public Retangulo(int largura, int altura) {
		this.largura = largura;
		this.altura = altura;
	}
	
	public double calculaArea() {
		return this.largura * this.altura;
	}
}
[/code]

Repare que, aqui, se você tivesse usado herança, não iria ganhar muito, já que cada implementação 
é totalmente diferente da outra: um %%Quadrado%%, um %%Retangulo%% e um %%Circulo%% têm atributos e 
métodos **bem** diferentes. 

Mas, mesmo que eles tivessem atributos em comum, utilizar interfaces é uma maneira muito mais 
elegante de modelar suas classes. Elas também trazem vantagens em não acoplar as classes. Uma vez 
que herança através de classes traz muito acoplamento, muitos autores renomados dizem que, na maioria dos 
casos, **herança quebra o encapsulamento**, pensamento com o qual a equipe da Caelum concorda 
plenamente.

Crie a seguinte classe de %%Teste%%. Repare no polimorfismo. Poderíamos passar esses objetos como 
argumento para alguém que aceitasse %%AreaCalculavel%% como argumento:

[code java]
class Teste {	
	public static void main(String[] args) {
		AreaCalculavel a = new Retangulo(3,2);
		System.out.println(a.calculaArea());
	}
}
[/code]

Opcionalmente, crie a classe %%Circulo%%:

[code java]
class Circulo implements AreaCalculavel {
	// ... atributos (raio) e métodos (calculaArea)
}
[/code]

Utilize %%Math.PI * raio * raio%% para calcular a área.

[/question]
[question]
Nosso banco precisa tributar dinheiro de alguns bens que nossos clientes possuem. Para isso, vamos 
criar uma interface no nosso projeto ::banco:: já existente:

[code java]
interface Tributavel {
	double calculaTributos();
}
[/code]

Lemos essa interface da seguinte maneira: "todos que quiserem ser ::tributável:: precisam saber 
::calcular tributos::, devolvendo um double".

Alguns bens são tributáveis e outros não, %%ContaPoupanca%% não é tributável, já para 
%%ContaCorrente%% você precisa pagar 1% da conta e o %%SeguroDeVida%% tem uma taxa fixa de 42 reais.

Aproveite o Eclipse! Quando você escrever %%implements Tributavel%% na classe %%ContaCorrente%%,
o ::quick fix:: do Eclipse vai sugerir que você reescreva o método; escolha essa opção e, depois,
preencha o corpo do método adequadamente:

[code java]
class ContaCorrente extends Conta implements Tributavel {
	
	// outros atributos e metodos
	
	public double calculaTributos() {
		return this.getSaldo() * 0.01;
	}
}
[/code]

Crie a classe %%SeguroDeVida%%, aproveitando novamente do Eclipse, para obter:

[code java]
class SeguroDeVida implements Tributavel {
	public double calculaTributos() {
		return 42;
	}
}
[/code]

[img images/interfaces/interface_tributavel.png w=55]

Vamos criar uma classe %%TestaTributavel%% com um método %%main%% para testar o nosso exemplo:

[code java]
class TestaTributavel {

	public static void main(String[] args) {
		ContaCorrente cc = new ContaCorrente();
		cc.deposita(100);
		System.out.println(cc.calculaTributos());
		
		// testando polimorfismo:
		Tributavel t = cc;
		System.out.println(t.calculaTributos());
	}
}
[/code]

Tente chamar o método %%getSaldo%% através da referência %%t%%, o que ocorre? Por quê? 

A linha em que atribuímos %%cc%% a um %%Tributavel%% é apenas para você enxergar que é possível 
fazê-lo. Nesse nosso caso, isso não tem uma utilidade. Essa possibilidade será útil para o próximo 
exercício.

[note]
	%%Tributavel t = cc%% gera muitas duvidas na cabeca do pessoal. Normal! Eles so precisam saber que isso
	pode ser feito, nao que isso tem alguma utilidade!

	Isso so vai ser util e vai ficar claro quando eles verem collections %%List x = new ArrayList()%%
[/note]
[/question]

[question]
(opcional) Crie um %%GerenciadorDeImpostoDeRenda%%, que recebe todos os tributáveis de uma pessoa e 
soma seus valores, e inclua nele um método para devolver seu total:

[code java]
class GerenciadorDeImpostoDeRenda {
	private double total;
	
	void adiciona(Tributavel t) {
		System.out.println("Adicionando tributavel: " + t);
	
		this.total +=  t.calculaTributos();
	}
		
	public double getTotal() {
		return this.total;
	}
}
[/code]

Crie um %%main%% para instanciar diversas classes que implementam %%Tributavel%% e passar como 
argumento para um %%GerenciadorDeImpostoDeRenda%%. Repare que você não pode passar qualquer tipo de 
conta para o método adiciona, apenas a que implementa %%Tributavel%%. Além disso, pode passar o 
%%SeguroDeVida%%.

[code java]
public class TestaGerenciadorDeImpostoDeRenda {
	public static void main(String[] args) {
			
		GerenciadorDeImpostoDeRenda gerenciador = new GerenciadorDeImpostoDeRenda();
				
		SeguroDeVida sv = new SeguroDeVida();
		gerenciador.adiciona(sv);
			
		ContaCorrente cc = new ContaCorrente();
		cc.deposita(1000);
		gerenciador.adiciona(cc);
			
		System.out.println(gerenciador.getTotal());
	}
}
[/code]

Repare que, de dentro do %%GerenciadorDeImpostoDeRenda%%, você não pode acessar o método %%getSaldo%%, 
por exemplo, pois você não tem a garantia de que o %%Tributavel%% que vai ser passado como argumento 
tem esse método. A única certeza que você tem é de que esse objeto tem os métodos declarados na 
interface %%Tributavel%%.

É interessante enxergar que as interfaces (como aqui, no caso, %%Tributavel%%) costumam ligar classes 
muito distintas, unindo-as por uma característica que elas tem em comum. No nosso exemplo, 
%%SeguroDeVida%% e %%ContaCorrente%% são entidades completamente distintas, porém ambas possuem a 
característica de serem tributáveis.

Se amanhã o governo começar a tributar até mesmo %%PlanoDeCapitalizacao%%, basta que essa
classe implemente a interface %%Tributavel%%! Repare no grau de desacoplamento que temos:
a classe %%GerenciadorDeImpostoDeRenda%% nem imagina que vai trabalhar como  %%PlanoDeCapitalizacao%%. 
Para ela, o único fato que importa é que o objeto respeite o contrato de um tributável, isso é, 
a interface %%Tributavel%%. Novamente: programe voltado a interface,
não a implementação.
[/question]

[question]
	(opcional) Use o método %%printf%% para imprimir o saldo com exatamente duas casas decimais:
	
	[code java]
		System.out.printf("O saldo é: %.2f", conta.getSaldo());
	[/code]
[/question]
[/exercise]

[section Exercícios avançados opcionais]
Atenção: caso você faça esse exercício, faça isso num projeto à parte %%conta-interface%% 
pois usaremos a %%Conta%% como classe em exercícios futuros.

[exercise]
[question]
(Opcional) Transforme a classe %%Conta%% em uma interface. 

[note]
	Hora para um bom exemplo de refactoring!

	Aqui voce pode depois mostrar aos alunos o Extract Interface:
	delete sua classe %%Conta%%, tire os extends e overrides de %%ContaCorrente%%
	e %%ContaPoupanca%%, e aplique extract interface em %%ContaCorrente%%!

	Muito melhor que um simples rename!
[/note]

[code java]
interface Conta {
	double getSaldo();
	void deposita(double valor);
	void retira(double valor);
	void atualiza(double taxaSelic);
}
[/code]

Adapte %%ContaCorrente%% e %%ContaPoupanca%% para essa modificação:

[code java]
class ContaCorrente implements Conta {
	// ...
}
[/code]

[code java]
class ContaPoupanca implements Conta {
	// ...
}
[/code]

Algum código vai ter de ser copiado e colado? Isso é tão ruim?

[/question]

[question]
(Opcional) Subinterfaces: 

Às vezes, é interessante criarmos uma interface que herda de outras interfaces.

[code java]
interface ContaTributavel extends Conta, Tributavel {
}
[/code]

Dessa maneira, quem for implementar essa nova interface precisa implementar todos os métodos herdados 
das suas superinterfaces (e talvez ainda novos métodos declarados dentro dela):

[code java]
class ContaCorrente implements ContaTributavel {
  // metodos
}
	
Conta c = new ContaCorrente();
Tributavel t = new ContaCorrente();
[/code]

Repare que o código pode parecer estranho, pois a interface não declara método algum, só herda os 
métodos abstratos declarados nas outras interfaces.

Ao mesmo tempo que uma interface pode herdar de mais de uma outra interface, classes só podem possuir 
uma classe mãe (herança simples).
[/question]
[/exercise]

[section Discussão em aula: Favorecer composição em relação à herança]

Discuta com o instrutor e seus colegas, alternativas à herança. Falaremos
de herança versus composição e porque herança é muitas vezes considerada
maléfica.

Numa entrevista, James Gosling, "pai do java", fala 
sobre uma linguagem puramente de delegação e chega a dizer:.

::Rather than subclassing, just use pure interfaces. 
It's not so much that class inheritance is particularly bad. It just 
has problems.:: - James Gosling, na mesma entrevista.

http://www.artima.com/intv/gosling3P.html

No blog da Caelum há tambem um post sobre o assunto:
http://blog.caelum.com.br/2006/10/14/como-nao-aprender-orientacao-a-objetos-heranca/

[note]
Você poderia diminuir esse 
::copia e cola:: e centralizar esses códigos repetidos em um lugar só: imagine
uma classe chamada %%ManipuladorDeSaldo%% que possua os métodos
que trabalham com depósito, saque, transferência, etc. Cada uma das
contas teriam referência para um %%ManipuladorDeSaldo%%  e **delegariam**
chamadas para este objeto. Conta **tem** %%ManipuladorDeSaldo%%, mas não
**é um** %%ManipuladorDeSaldo%%: uma reção muito mais amena.

Pesquise sobre Herança versus Composição: é um tema em discussão desde
a época do livro Design Patterns, em 1995, onde é citado com um
princípio da boa orientação a objetos:

**Favor object composition over class inheritance**
[/note]
