[chapter Orientação a Objetos - herança, reescrita e polimorfismo]
[quote "O homem absurdo é aquele que nunca muda." -- Georges Clemenceau]

Ao término desse capítulo, você será capaz de:
[list]
* dizer o que é herança e quando utilizá-la;
* reutilizar código escrito anteriormente;
* criar classes filhas e reescrever métodos;
* usar todo o poder que o polimorfismo dá.
[/list]

[note]
* o ponto crucial é que os alunos tenham um estalo e enxerguem a vantagem de usar polimorfismo 
quando forem receber argumentos, dessa forma os switches são eliminados porque podemos 
reescrever os métodos.

* É importante estar nesta parte, ou no começo da aula, em caso de curso noturno, ou por 
volta das 14:30 para que haja tempo para os exercícios 

* Ao instrutor, segue a dica de utilizar-se dos diagramas UML que estão na apostila 
durante as explicações para facilitar o entendimento dos alunos.

* Ao mostrar diagramas falar mais ou menos o que é UML e que aquilo eh quase
um diagrama de classes
[/note]

[section Repetindo código?]
Como toda empresa, nosso Banco possui funcionários. Vamos modelar a classe %%Funcionario%%:

[code java]
	class Funcionario {
		String nome;
		String cpf;
		double salario;
		 // métodos devem vir aqui
	}
[/code]

Além de um funcionário comum, há também outros cargos, como os gerentes. Os gerentes guardam a mesma 
informação que um funcionário comum, mas possuem outras informações, além de ter funcionalidades um 
pouco diferentes. Um gerente no nosso banco possui também uma senha numérica que permite o acesso ao 
sistema interno do banco, além do número de funcionários que ele gerencia:

[code java]
class Gerente {
	String nome;
	String cpf;
	double salario;
	int senha;
	int numeroDeFuncionariosGerenciados;
		
	public boolean autentica(int senha) {
		if (this.senha == senha) {
			System.out.println("Acesso Permitido!");
			return true;
		} else {
			System.out.println("Acesso Negado!");
			return false;
		}
	}
	
	// outros métodos 
}
[/code]

[box Precisamos mesmo de outra classe?]
Poderíamos ter deixado a classe %%Funcionario%% mais genérica, mantendo nela senha de acesso, e o
número de funcionários gerenciados. Caso o funcionário não fosse um gerente, deixaríamos estes 
atributos vazios.

Essa é uma possibilidade, porém podemos começar a ter muito atributos opcionais, e a classe
ficaria estranha. E em relação aos métodos? A classe %%Gerente%% tem o método %%autentica%%, 
que não faz sentido existir em um funcionário que não é gerente.
[/box]

[note]
Outra solução meia-boca: colocar uma flag que indica o cargo. Em alguns casos
pode fazer sentido.
[/note]

Se tivéssemos um outro tipo de funcionário que tem características diferentes do funcionário comum, 
precisaríamos criar uma outra classe e copiar o código novamente!

Além disso, se um dia precisarmos adicionar uma nova informação para todos os funcionários, 
precisaremos passar por todas as classes de funcionário e adicionar esse atributo. 
O problema acontece novamente por não centralizarmos as informações principais do funcionário em um 
único lugar!

[index HERANÇA, EXTENDS]
Existe um jeito, em Java, de relacionarmos uma classe de tal maneira que uma delas **herda** tudo que 
a outra tem. Isto é uma relação de classe mãe e classe filha. No nosso caso, gostaríamos de fazer com 
que o %%Gerente%% tivesse tudo que um %%Funcionario%% tem, gostaríamos que ela fosse uma **extensão** 
de %%Funcionario%%. Fazemos isto através da palavra chave %%extends%%.

[code java]
	class Gerente extends Funcionario {
		int senha;
		int numeroDeFuncionariosGerenciados;
		
		public boolean autentica(int senha) {
			if (this.senha == senha) {
				System.out.println("Acesso Permitido!");
				return true;
			} else {
				System.out.println("Acesso Negado!");
				return false;
			}
		}
		
		// setter da senha omitido
	}
[/code]

Em todo momento que criarmos um objeto do tipo %%Gerente%%, este objeto possuirá também os atributos 
definidos na classe %%Funcionario%%, pois um %%Gerente%% **é um** %%Funcionario%%:

[img images/orientacaoobjetos/extends.png w=15]

[code java]
	class TestaGerente {
		public static void main(String[] args) {
			Gerente gerente = new Gerente();
			
			// podemos chamar metodos do Funcionario:
			gerente.setNome("João da Silva");
			
			// e tambem metodos do Gerente!
			gerente.setSenha(4231);
		}
	}
[/code]

[note]
Utilizar nomenclaturas conhecidas como: herdar, especializar, filha, mãe, ::superclasse:: e ::subclasse::.
Sempre desenhar a setinha na lousa de G para F. Aumente o exemplo e fale de Diretor,
Secretario, Engenheiro e desenhe a arvore.
[/note]

Dizemos que a classe %%Gerente%% **herda** todos os atributos e métodos da classe mãe, no nosso caso, 
a %%Funcionario%%. Para ser mais preciso, ela também herda os atributos e métodos privados, porém não 
consegue acessá-los diretamente.

[index Super e sub classes]
[box Super e Sub classe]
A nomenclatura mais encontrada é que %%Funcionario%% é a **superclasse** de %%Gerente%%, e 
%%Gerente%% é a **subclasse** de %%Funcionario%%. Dizemos também que todo %%Gerente%% **é um** 
%%Funcionário%%. Outra forma é dizer que %%Funcionario%% é classe **mãe** de %%Gerente%%
e %%Gerente%% é classe **filha** de %%Funcionario%%. 
[/box]

[index PROTECTED]
E se precisamos acessar os atributos que herdamos? Não gostaríamos de deixar os atributos de 
%%Funcionario%%, %%public%%, pois dessa maneira qualquer um poderia alterar os atributos dos objetos 
deste tipo. Existe um outro modificador de acesso, o %%protected%%, que fica entre o %%private%% e o 
%%public%%. Um atributo %%protected%% só pode ser acessado (visível) pela própria classe e por suas 
subclasses (e mais algumas outras classes, mas veremos isso em outro capítulo).

[code java]
	class Funcionario {
		protected String nome;
		protected String cpf;
		protected double salario;
		// métodos devem vir aqui
	}
[/code]

[box Sempre usar protected?]
Então porque usar %%private%%? Depois de um tempo programando orientado a objetos, você vai começar a 
sentir que nem sempre é uma boa ideia deixar que a classe filha acesse os atributos da classe mãe, 
pois isso quebra um pouco a ideia de que só aquela classe deveria manipular seus atributos. Essa é 
uma discussão um pouco mais avançada.

Além disso, não só as subclasses, mas também as outras classes, podem acessar os atributos 
%%protected%%, que veremos mais a frente (mesmo pacote). Veja outras alternativas ao %%protected%% no
exercício de discussão em sala de aula juntamente com o instrutor.
[/box]

Da mesma maneira, podemos ter uma classe %%Diretor%% que estenda %%Gerente%% e a classe 
%%Presidente%% pode estender diretamente de %%Funcionario%%.

Fique claro que essa é uma decisão de negócio. Se Diretor vai estender de Gerente ou não, vai 
depender se, para você, Diretor ::é um:: Gerente.

Uma classe pode ter várias filhas, mas pode ter apenas uma mãe, é a chamada herança simples do java.

[img images/orientacaoobjetos/uml-heranca.png w=70%]

[section Reescrita de método]
[index REESCRITA DE MÉTODO]
[note]
Na lousa, voce pode mostrar a reescrita com o metodo %%mostra%% antes
do getBonificacao. Assim voce da dois exemplos, e ja mostra tambem o acesso
ao super.mostra().
[/note]

Todo fim de ano, os funcionários do nosso banco recebem uma bonificação. Os funcionários comuns 
recebem 10% do valor do salário e os gerentes, 15%.

Vamos ver como fica a classe %%Funcionario%%:

[code java]
	class Funcionario {
		protected String nome;
		protected String cpf;
		protected double salario;
		
		public double getBonificacao() {
			return this.salario * 0.10;
		}
		// métodos
	}
[/code]

Se deixarmos a classe %%Gerente%% como ela está, ela vai herdar o método %%getBonificacao%%.

[code java]
	Gerente gerente = new Gerente();
	gerente.setSalario(5000.0);
	System.out.println(gerente.getBonificacao());
[/code]

[index REESCRITA]
O resultado aqui será 500. Não queremos essa resposta, pois o gerente deveria ter 750 de bônus nesse caso.
Para consertar isso, uma das opções seria criar
um novo método na classe %%Gerente%%, chamado, por exemplo, %%getBonificacaoDoGerente%%. O problema é que
teríamos dois métodos em %%Gerente%%, confundindo bastante quem for usar essa classe, além de que cada
um da uma resposta diferente. 

No Java, quando herdamos um método, podemos alterar seu comportamento. Podemos **reescrever** (reescrever, 
sobrescrever, ::override::) este método:

[code java]
	class Gerente extends Funcionario {
		int senha;
		int numeroDeFuncionariosGerenciados;

		public double getBonificacao() {
			return this.salario * 0.15;
		}
		// ...
	}
[/code]

Agora o método está correto para o %%Gerente%%. Refaça o teste e veja que o valor 
impresso é o correto (750):

[code java]
	Gerente gerente = new Gerente();
	gerente.setSalario(5000.0);
	System.out.println(gerente.getBonificacao());
[/code]

[section Invocando o método reescrito]
Depois de reescrito, não podemos mais chamar o método antigo que fora herdado da classe mãe: realmente alteramos
o seu comportamento. Mas podemos invocá-lo no caso de estarmos dentro da classe.

Imagine que para calcular a bonificação de um %%Gerente%% devemos fazer igual ao cálculo de um 
%%Funcionario%% porem adicionando R$ 1000. Poderíamos fazer assim:

[code java]
	class Gerente extends Funcionario {
		int senha;
		int numeroDeFuncionariosGerenciados;
		
		public double getBonificacao() {
			return this.salario * 0.10 + 1000;
		}
		 // ...
	}
[/code]

Aqui teríamos um problema: o dia que o %%getBonificacao%% do %%Funcionario%% mudar, precisaremos mudar o 
método do %%Gerente%% para acompanhar a nova bonificação. Para evitar isso, o 
%%getBonificacao%% do %%Gerente%% pode chamar o do %%Funcionario%% utilizando a palavra chave 
%%super%%.

[code java]
	class Gerente extends Funcionario {
		int senha;
		int numeroDeFuncionariosGerenciados;
	
		public double getBonificacao() {
			return super.getBonificacao() + 1000;
		}
		 // ...
	}
[/code]

Essa invocação vai procurar o método com o nome %%getBonificacao%% de uma super classe de %%Gerente%%.
No caso ele logo vai encontrar esse método em %%Funcionario%%.

Essa é uma prática comum, pois muitos casos o método reescrito geralmente faz "algo a mais" que o método da 
classe mãe. Chamar ou não o método de cima é uma decisão sua e depende do seu problema. Algumas vezes não 
faz sentido invocar o método que reescrevemos. 

[section Polimorfismo]
[note]
Dizer que Java é fortemente tipado (acredito que isso já foi dito antes), ou seja, nasce 
Gerente, morre Gerente. (Alguma brincadeira pode ser feita aqui).

"No banco existe uma sala de coffee break que, possui uma placa na porta com o dizer de que o acesso 
só é permitido a funcionários. Sabe-se que, todos os que estão lá dentro são funcionários, independente 
do cargo que possuem, ou seja, existem lá dentro secretárias, gerentes, programadores, analistas, 
diretores, etc. Eu sei que todo funcionário possui um salário. Posso perguntar o salário para 
alguém que está lá dentro? Se for um gerente, o que ele vai me responder, o salário de um gerente 
ou de um funcionário? No java é o mesmo!".

Voltando ao java, escrever o código Funcionário f = new Gerente(); 
Fazer o desenho na lousa e explicar o que acontece, sempre lembrando da salinha do café.

Fazer o Controle de bonificações. Pergunta, eu preciso colocar um método para cada 
tipo de funcionário? Refazer a pergunta da seguinte maneira: "Eu preciso ter uma 
porta para cada tipo de funcionário? ou uma unica serve?".
[/note]

O que guarda uma variável do tipo %%Funcionario%%? Uma referência para um %%Funcionario%%, nunca
o objeto em si.

Na herança, vimos que todo %%Gerente%% é um %%Funcionario%%, pois é uma extensão deste. Podemos nos 
referir a um %%Gerente%% como sendo um %%Funcionario%%. Se alguém precisa falar com um 
%%Funcionario%% do banco, pode falar com um %%Gerente%%! Porque? Pois %%Gerente%% **é um** 
%%Funcionario%%. Essa é a semântica da herança.

[code java]
	Gerente gerente = new Gerente();
	Funcionario funcionario = gerente; 
	funcionario.setSalario(5000.0);
[/code]

[index POLIMORFISMO]
[img images/orientacaoobjetos/heranca-simples.png w=40]

Polimorfismo é a capacidade de um objeto poder ser referenciado de várias formas. (cuidado, 
polimorfismo não quer dizer que o objeto fica se transformando, muito pelo contrário, um objeto 
nasce de um tipo e morre daquele tipo, o que pode mudar é a maneira como nos referimos a ele).

Até aqui tudo bem, mas e se eu tentar:

[code java]	funcionario.getBonificacao();[/code]

Qual é o retorno desse método? 500 ou 750? No Java, a invocação de método sempre vai ser **decidida em 
tempo de execução**. O Java vai procurar o objeto na memória e, aí sim, decidir qual método deve ser 
chamado, sempre relacionando com sua classe de verdade, e não com a que estamos usando para 
referenciá-lo. Apesar de estarmos nos referenciando a esse %%Gerente%% como sendo um %%Funcionario%%, 
o método executado é o do %%Gerente%%. O retorno é 750.

Parece estranho criar um gerente e referenciá-lo como apenas um funcionário. Por que faríamos isso? 
Na verdade, a situação que costuma aparecer é a que temos um método que recebe um argumento do tipo 
%%Funcionario%%:

[note]
Legal aproveitar pra revisar com a galera um pouco de OO:
[code java]
class ControladorDeBonificacao {
	private double bonusTotal; }
[/code]
Como fazemos para que o valor do bônus do Diretor, Gerente... seja adicionado ao
bonus total? Ao invés de implementarmos o método vamos pensar em como usá-lo.
[code java]
...main() {
ControladorDeBonificacao controle = new ControladorDeBonificacao();
Gerente gerente = new Gerente(4000);
controle.adicionaBonus(?????);
[/code]
Como conseguimos passar o bonus do Gerente para o controle?
[code java]
controle.adicionaBonus(gerente.getBonificacao());
[/code]
Ficou bom? Vamos implementar?
[code java]
class ControladorDeBonificacao {
	public void adicionaBonus(double valor) {this.bonusTotal+= valor}}
[/code]
Funciona para Diretor, Gerente, Secretário, Engenheiro? (mostrar no main())
Esse método garante que o valor passado será um bônus?
[code java]
...main() {
	controle.adicionaBonus(-10); //throll
	controle.adicionaBonus(gerente.getSalario()); //erro honesto
[/code]
Estamos separando dados de comportamento!!! Melhor fazermos a chamada de getBonificacao()
dentro do método adicionaBonus. Como?!?
[code java]
	public void adicionaBonus(????) {
		???getBonificacao(); }
[/code]
Depois a motivação padrão de pedirmos um tipo e fazermos a sobrecarga para depois puxar pro
polimorfismo.
[/note]

[code java]
	class ControleDeBonificacoes {
		private double totalDeBonificacoes = 0;

		public void registra(Funcionario funcionario) {
			this.totalDeBonificacoes += funcionario.getBonificacao();
		}

		public double getTotalDeBonificacoes() {
			return this.totalDeBonificacoes;
		}
	}
[/code]

E, em algum lugar da minha aplicação (ou no %%main%%, se for apenas para testes):

[code java]
	ControleDeBonificacoes controle = new ControleDeBonificacoes();

	Gerente funcionario1 = new Gerente();
	funcionario1.setSalario(5000.0);
	controle.registra(funcionario1);

	Funcionario funcionario2 = new Funcionario();
	funcionario2.setSalario(1000.0);
	controle.registra(funcionario2);

	System.out.println(controle.getTotalDeBonificacoes());
[/code]

Repare que conseguimos passar um %%Gerente%% para um método que recebe um %%Funcionario%% como 
argumento. Pense como numa porta na agência bancária com o seguinte aviso: "Permitida a entrada 
apenas de Funcionários". Um gerente pode passar nessa porta? Sim, pois %%Gerente%% **é um** 
%%Funcionario%%.

Qual será o valor resultante? Não importa que dentro do método registra do %%ControleDeBonificacoes%% 
receba %%Funcionario%%. Quando ele receber um objeto que realmente é um %%Gerente%%, o seu método 
reescrito será invocado. Reafirmando: **não importa como nos referenciamos a um objeto, o método que 
será invocado é sempre o que é dele**.

No dia em que criarmos uma classe %%Secretaria%%, por exemplo, que é filha de %%Funcionario%%, 
precisaremos mudar a classe de %%ControleDeBonificacoes%%? Não. Basta a classe %%Secretaria%% 
reescrever os métodos que lhe parecerem necessários. É exatamente esse o poder do polimorfismo, 
juntamente com a reescrita de método: diminuir o acoplamento entre as classes, para evitar que
novos códigos resultem em modificações em inúmeros lugares.

Repare que quem criou %%ControleDeBonificacoes%% pode nunca ter imaginado a criação da classe 
%%Secretaria%% ou %%Engenheiro%%. Contudo, não será necessário reimplementar esse controle em cada 
nova classe: reaproveitamos aquele código.

[box Herança ::versus:: acoplamento]
Note que o uso de herança **aumenta** o acoplamento entre as classes, isto é, o quanto uma classe 
depende de outra. A relação entre classe mãe e filha é muito forte e isso acaba fazendo com que o 
programador das classes filhas tenha que conhecer a implementação da classe pai e vice-versa - fica 
difícil fazer uma mudança pontual no sistema.

Por exemplo, imagine se tivermos que mudar algo na nossa classe %%Funcionario%%, mas não quiséssemos 
que todos os funcionários sofressem a mesma mudança. Precisaríamos passar por cada uma das filhas de 
%%Funcionario%% verificando se ela se comporta como deveria ou se devemos sobreescrever o tal 
método modificado.

Esse é um problema da herança, e não do polimorfismo, que resolveremos mais tarde com a ajuda de 
Interfaces.
[/box]

[section Um outro exemplo]
Imagine que vamos modelar um sistema para a faculdade que controle as despesas com funcionários e 
professores. Nosso funcionário fica assim:

[code java]
	class EmpregadoDaFaculdade {
		private String nome;
		private double salario;
		double getGastos() {
			return this.salario;
		}
		String getInfo() {
			return "nome: " + this.nome + " com salário " + this.salario;
		}
		 // métodos de get, set e outros
	}
[/code]

O gasto que temos com o professor não é apenas seu salário. Temos de somar um bônus de 10 reais por 
hora/aula. O que fazemos então? Reescrevemos o método. Assim como o %%getGastos%% é diferente, o 
%%getInfo%% também será, pois temos de mostrar as horas/aula também.

[code java]
	class ProfessorDaFaculdade extends EmpregadoDaFaculdade {
		private int horasDeAula;
		double getGastos() {
			return this.getSalario() + this.horasDeAula * 10;
		}
		String getInfo() {
			String informacaoBasica = super.getInfo();
			String informacao = informacaoBasica + " horas de aula: " + this.horasDeAula;
			return informacao;
		}
		// métodos de get, set e outros
	}
[/code]

A novidade, aqui, é a palavra chave %%super%%. Apesar do método ter sido reescrito, gostaríamos de 
acessar o método da classe mãe, para não ter de copiar e colocar o conteúdo desse método e depois 
concatenar com a informação das horas de aula.

Como tiramos proveito do polimorfismo? Imagine que temos uma classe de relatório:

[code java]
	class GeradorDeRelatorio {
		public void adiciona(EmpregadoDaFaculdade f) {
			System.out.println(f.getInfo());
			System.out.println(f.getGastos());
		}
	}
[/code]

Podemos passar para nossa classe qualquer %%EmpregadoDaFaculdade%%! Vai funcionar tanto para professor, 
quanto para funcionário comum.

Um certo dia, muito depois de terminar essa classe de relatório, resolvemos aumentar nosso sistema, 
e colocar uma classe nova, que representa o %%Reitor%%. Como ele também é um 
%%EmpregadoDaFaculdade%%, será que vamos precisar alterar algo na nossa classe de 
%%Relatorio%%? Não. Essa é a ideia! Quem programou a classe %%GeradorDeRelatorio%% nunca imaginou que 
existiria uma classe Reitor e, mesmo assim, o sistema funciona.

[code java]
	class Reitor extends EmpregadoDaFaculdade {
		 // informações extras
		String getInfo() {
			return super.getInfo() + " e ele é um reitor";
		}
		 // não sobreescrevemos o getGastos!!!
	}
[/code]

[section Um pouco mais...]
[list number]
* Se não houvesse herança em Java, como você poderia reaproveitar o código de outra classe?
[index COMPOSIÇÃO]

* Uma discussão muito atual é sobre o abuso no uso da herança. Algumas pessoas usam herança apenas 
para reaproveitar o código, quando poderiam ter feito uma **composição**.
Procure sobre herança versus composição.

* Mesmo depois de reescrever um método da classe mãe, a classe filha ainda pode acessar o método 
antigo. Isto é feito através da palavra chave %%super.método()%%. Algo parecido ocorre entre os 
construtores das classes, o que?
[/list]

[box Mais sobre o mau uso da herança]
No blog da Caelum existe um artigo interessante abordando esse tópico:

http://blog.caelum.com.br/2006/10/14/como-nao-aprender-orientacao-a-objetos-heranca/


James Gosling, um dos criadores do Java, é um crítico do mau uso da herança.
Nesta entrevista ele discute a possibilidade de se utilizar apenas interfaces e composição,
eliminando a necessidade da herança:

http://www.artima.com/intv/gosling3P.html
[/box]

[section Exercícios: Herança e Polimorfismo]
[Exercise]
[Question]
Vamos criar uma classe %%Conta%%, que possua um %%saldo%%, e os métodos para pegar saldo, depositar, e sacar.

[list letter]
* Crie a classe %%Conta%%:
[code java]
	class Conta {
	}
[/code]

* Adicione o atributo %%saldo%%
[code java]
	class Conta {
		private double saldo;
	}
[/code]

* Crie os métodos %%getSaldo()%%, %%deposita(double)%% e %%saca(double)%%
[code java]
	class Conta {
		private double saldo;

		void deposita(double valor) {
			this.saldo += valor;
		}

		void saca(double valor) {
			this.saldo -= valor;
		}

		double getSaldo() {
			return this.saldo;
		}
	}
[/code]
[/list]
[Answer]
[code java]
	class Conta{
		protected double saldo;
		
		public double getSaldo() {
			return this.saldo;
		}
		
		public void deposita(double valor) {
			this.saldo += valor;
		}

		public void saca(double valor) {
			this.saldo -= valor;
		}

		public void atualiza(double taxa) {
			this.saldo += this.saldo * taxa;
		}
	}
[/code]
[/Answer]
[/Question]
[Question]
Adicione um método na classe %%Conta%%, que atualiza essa conta de acordo com uma taxa percentual 
fornecida.

[code java]
	class Conta {
		private double saldo;
		
		 // outros métodos aqui também ...
		 
		void atualiza(double taxa) {
			this.saldo += this.saldo * taxa;
		}
	}
[/code]
[Answer]
[code java]
	public void atualiza(double taxa) {
		this.saldo += this.saldo * taxa;
	}
[/code]
[/Answer]
[/Question]
[Question]
Crie duas subclasses da classe %%Conta%%: %%ContaCorrente%% e %%ContaPoupanca%%. Ambas terão o método 
atualiza reescrito: A %%ContaCorrente%% deve atualizar-se com o dobro da taxa e a %%ContaPoupanca%% 
deve atualizar-se com o triplo da taxa.

Além disso, a %%ContaCorrente%% deve reescrever o método %%deposita%%, afim de retirar uma taxa bancária 
de dez centavos de cada depósito.

[note]
Antigamente aqui, a reescrita do deposita da ContaCorrente retirava a cpmf,
entao bastava multiplicar o valor por 0.9962. Era muito mais interessante porque
era bem proximo da realidade. Voce pode citar isso como exemplo tambem.
[/note]

[list]
* Crie as classes %%ContaCorrente%% e %%ContaPoupanca%%. Ambas são filhas da classe %%Conta%%:

[code java]
	class ContaCorrente extends Conta {
	}

	class ContaPoupanca extends Conta {
	}
[/code]

* Reescreva o método %%atualiza%% na classe %%ContaCorrente%%, seguindo o enunciado:

[code java]
	class ContaCorrente extends Conta {
		void atualiza(double taxa) {
			this.saldo += this.saldo * taxa * 2;
		}
	}
[/code]

Repare que, para acessar o atributo saldo herdado da classe %%Conta%%, você vai precisar trocar o 
modificador de visibilidade de saldo para %%protected%%. 

* Reescreva o método %%atualiza%% na classe %%ContaPoupanca%%, seguindo o enunciado:

[code java]
	class ContaPoupanca extends Conta {
		void atualiza(double taxa) {
			this.saldo += this.saldo * taxa * 3;
		}
	}
[/code]

* Na classe %%ContaCorrente%%, reescreva o método %%deposita%% para descontar a taxa bancária de dez
centavos:

[code java]
	class ContaCorrente extends Conta {
		void atualiza(double taxa) {
			this.saldo += this.saldo * taxa * 2;
		}

		void deposita(double valor) {
			this.saldo += valor - 0.10;
		}
	}
[/code]

[img images/orientacaoobjetos/polimorfismo.png w=40%]
[/list]

[/Question]

[Question]
Crie uma classe com método %%main%% e instancie essas classes, atualize-as e veja o resultado. Algo 
como:

[code java]
	class TestaContas {
		public static void main(String[] args) {
			Conta c = new Conta();
			ContaCorrente cc = new ContaCorrente();
			ContaPoupanca cp = new ContaPoupanca();
	
			c.deposita(1000); 
			cc.deposita(1000); 
			cp.deposita(1000);
	
			c.atualiza(0.01);
			cc.atualiza(0.01);
			cp.atualiza(0.01);
		
			System.out.println(c.getSaldo());
			System.out.println(cc.getSaldo());
			System.out.println(cp.getSaldo());

		}
	}
[/code]

Após imprimir o saldo (%%getSaldo()%%) de cada uma das contas, o que acontece?
[/Question]
[Question]
O que você acha de rodar o código anterior da seguinte maneira:

[code java]
			Conta c = new Conta();
			Conta cc = new ContaCorrente();
			Conta cp = new ContaPoupanca();
[/code]

Compila? Roda? O que muda? Qual é a utilidade disso? Realmente, essa não é a maneira mais útil do 
polimorfismo - veremos o seu real poder no próximo exercício. Porém existe uma utilidade de 
declararmos uma variável de um tipo menos específico do que o objeto realmente é.

É **extremamente importante** perceber que não importa como nos referimos a um objeto, o método que será 
invocado é sempre o mesmo! A JVM vai descobrir em tempo de execução qual deve ser invocado, 
dependendo de que tipo é aquele objeto, não importando como nos referimos a ele.
[/Question]
[Question]
[TODO saldoTotal?!?! pra que? melhorar isso]
(opcional) Vamos criar uma classe que seja responsável por fazer a atualização de todas as contas 
bancárias e gerar um relatório com o saldo anterior e saldo novo de cada uma das contas.

[code java]
	class AtualizadorDeContas {
		private double saldoTotal = 0;
		private double selic;
	
		AtualizadorDeContas(double selic) {
			this.selic = selic;
		}
	
		void roda(Conta c) {
			// aqui voce imprime o saldo anterior, atualiza a conta, 
			// e depois imprime o saldo final
			// lembrando de somar o saldo final ao atributo saldoTotal
		}

		// outros métodos, colocar o getter para saldoTotal!
	}
[/code]
[/Question]
[Question]
(opcional) No método %%main%%, vamos criar algumas contas e rodá-las:

[code java]
	class TestaAtualizadorDeContas {
		public static void main(String[] args) {
			Conta c = new Conta();
			Conta cc = new ContaCorrente();
			Conta cp = new ContaPoupanca();
			
			c.deposita(1000); 
			cc.deposita(1000); 
			cp.deposita(1000);

			AtualizadorDeContas adc = new AtualizadorDeContas(0.01);
					
			adc.roda(c);
			adc.roda(cc);
			adc.roda(cp);

			System.out.println("Saldo Total: " + adc.getSaldoTotal());
		}
	
	}
[/code]
[/Question]

[Question]
(Opcional) Use a palavra chave %%super%% nos métodos %%atualiza%% reescritos, para não ter de refazer o 
trabalho.
[/Question]

[Question]
(Opcional) Se você precisasse criar uma classe %%ContaInvestimento%%, e seu método %%atualiza%% fosse 
complicadíssimo, você precisaria alterar a classe %%AtualizadorDeContas%%? 
[/Question]

[Question]
(Opcional, Trabalhoso) Crie uma classe %%Banco%% que possui um array de %%Conta%%. Repare que num array de 
%%Conta%% você pode colocar tanto %%ContaCorrente%% quanto %%ContaPoupanca%%. Crie um método %%void 
adiciona(Conta c)%%, um método %%Conta pegaConta(int x)%% e outro %%int pegaTotalDeContas()%%, muito 
similar a relação anterior de Empresa-Funcionario.

Faça com que seu método %%main%% crie diversas contas, insira-as no %%Banco%% e depois, com um 
%%for%%, percorra todas as contas do %%Banco%% para passá-las como argumento para o 
%%AtualizadorDeContas%%.
[/Question]
[/Exercise]

[section Discussões em aula: Alternativas ao atributo protected]

Discuta com o instrutor e seus colegas alternativas ao uso do atributo %%protected%% na herança.
Preciso realmente afrouxar o encapsulamento do atributo por causa da herança? Como fazer para
o atributo continuar %%private%% na mãe e as filhas conseguirem de alguma formar trabalhar
com ele?

[note]
Vale muito a pena comentar isso depois do exercício (ou durante a correção).
O pessoal gosta dessas soluções e já começa a perceber os problemas de herança.

Muitas pessoas hoje em dia são críticas à herança pois dizem que esta enfraquece (quebra) o
encapsulamento. Quando começamos a aprender OO é difícil enxergar isso e essa discussão é
bastante avançada!

Mas no nosso sistema de Contas do exercício anterior já é possível sentir um pouco disto.
Tivemos que afrouxar o encapsulamento do nosso atributo %%saldo%% com o uso do %%protected%%.

Podíamos ter feito outras soluções e evitado essa quebra de encapsulamento. Nas classes filhas,
por exemplo, podemos reaproveitar os métodos da classe mãe:

[code java]
	class ContaCorrente extends Conta {
		void atualiza(double taxa) {
			super.atualiza(taxa * 2);
		}

		void deposita(double valor) {
			super.deposita(valor * 0.9962);
		}
	}
[/code]

Esta, aliás, é uma ótima prática. Imagine que o %%atualiza%% faz uma série de verificações antes
da atualização realmente: deste novo jeito não precisamos reescrever nada disso. Estamos dizendo:
"a %%ContaCorrente%% não sabe atualizar-se, mas sabe que a atualização deve ser feita com o dobro da taxa"
e então delegamos para %%Conta%%.

Outra solução, quando não há jeito e realmente achamos que precisamos abrir o acesso ao atributo, ao
invés de abri-lo como %%protected%%, usamos métodos de acesso get/set. No nosso exemplo, a %%ContaPoupanca%%
poderia usar %%getSaldo%% e %%setSaldo%%.

[code java]
	class ContaPoupanca extends Conta {
		void atualiza(double taxa) {
			this.setSaldo(this.getSaldo() + this.getSaldo() * taxa * 3);
		}
	}
[/code]

Mas não temos o %%setSaldo%% ainda! Então vamos lá na %%Conta%% e criamos o %%setSaldo%%, mas vamos deixá-lo
%%public%%? E todas as pessoas podem mudar o saldo?

Não, criamos o %%setSaldo%% como %%protected%%:

[code java]
class Conta {
	private double saldo;
	
	protected void setSaldo(String saldo) {
		this.saldo = saldo;
	}
}
[/code]

Note que, na verdade, ao invés de deixar o atributo %%protected%%, deixamos o método %%protected%%. Ainda
pode ser um quebra de encapsulamento, mas certamente menos grave que abrir o atributo. Depois, no futuro,
conseguimos adicionar verificações adicionais quando o valor do saldo muda apenas editando o %%setSaldo%%.
[/note]
